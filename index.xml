<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>右眼惺忪</title><link>//lyn-euler.github.io/</link><description>Recent content on 右眼惺忪</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 21 Jan 2020 00:00:00 +0000</lastBuildDate><atom:link href="//lyn-euler.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>架构整洁之道--边界</title><link>//lyn-euler.github.io/posts/2020_01_21-%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93-%E8%BE%B9%E7%95%8C.html</link><pubDate>Tue, 21 Jan 2020 00:00:00 +0000</pubDate><guid>//lyn-euler.github.io/posts/2020_01_21-%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93-%E8%BE%B9%E7%95%8C.html</guid><description>上一篇《架构整洁之道(上) &amp;mdash; 基础准备篇》中我们介绍了架构的一些基本概念和设计原则, 最后还学习了关于组件构建的一些原则. 这一篇我们来讲讲组件的边界划分.
边界 正如上一篇提到过的, 软件架构所追求的目标是最大限度地降低构建和维护一个系统所需的资源. 而这其中最消耗我们人力资源的又是什么? 答案是系统中存在的耦合 &amp;mdash; 尤其是那些过早作出的不成熟的决策所导致的耦合. 也就是那些和系统的业务需求(用例除外)无关的决策, 包括我们要采用的框架、数据库、Web服务器、工具库、依赖注入等. 在一个设计良好的系统架构中, 这些细节性的决策都应该是辅助性且可被推迟的, 我们的架构设计不应该依赖于这些细节, 而要尽可能的推迟这些细节性的决策, 并致力于将这种推迟所产生的影响降到最低. 所以如何将软件分割成各种元素, 以便约束元素之间的依赖关系就尤为重要了. 而边界的作用就在于此. 可以说软件架构设计的本身就是一门划分边界的艺术. 所谓的边界划分, 就是指在组件间建立变更的防火墙. 我们称在运行时, 一个组件调用另一个组件的函数并传递数据(或者说边界两侧函数调用和数据传递)的行为为跨边界调用.由于一个组件的源码变更会导致其他组件的源码也有可能会随之发生变更和重新编译, 所以要处理好跨边界调用就需要对源码中的依赖关系进行合理管控.
边界的形式 一个系统的架构是有组件以及他们之间的边界共同定义的. 那么这些边界又有哪些存在的形式呢?
源码层次上的解耦模式 最简单、最常见的架构边界通常并没有一个固定的物理形式, 他们只是对一个进程、同一个地址空间内的函数和数据进行某种划分, 也就是源码层次上的解耦模式. 从部署角度看, 最后都产生了一个单独的可执行文件&amp;mdash;也就是所谓的单体结构. 这类架构一般都需要利用某种动态形式的多态来管理其内部的依赖关系(这也是面向对象编程这类编程范式进几十年来一直是主流的原因).最简单的跨边界调用是由低层客户端来调用高层服务函数, 这种依赖关系在运行时和编译时都会保持一致.
但当高层组件的客户端需要调用底层组件的服务时, 我们就需要运用动态形式的多态来反转依赖关系了. 这种情况下, 运行时和编译的依赖关系就是相反的.
这种自律的组件划分可以极大地帮助整个项目的开发、测试和部署, 使不同团队可以同时开发不同的组件不会相互干扰. 高层组件与低层细节之间也可以得到良好的隔离, 独立演进.
部署层次的解耦模式 与单体架构类似, 其所有的函数仍然处于同一个进程、同一个地址空间中. 管理组件划分依赖关系的策略也基本一致. 不同的是这种模式将其所有可部署的单元打包成一个便于操作的文件格式, 不需要重新编译就可以交付的形式(二进制或其他等价的可部署形式), 比如最常见的物理边界形式&amp;mdash;动态链接库.
本地进程 系统架构还有一个更明显的物理边界形式:本地进程. 每个本地进程既可以是一个静态链接的单体结构 也可以是由多个动态链接组件构成的程序. 我们可以将本地进程看成膜中超级组件, 该进程由一系列的较低层次的组件组成, 我们将通过动态形式的多态来管理他们之间的依赖关系, 本地进程的隔离策略也与单体结构和动态链接库基本相同, 其源码中的依赖关系也是始终由低层组件指向高层策略. 对本地进程来说, 高层进程的源码中不应该包含低层进程的名字、物理内存地址或注册表键名. 应该让低层进程成为高层进程的一个插件. 本地进程跨边界调用需要用到系统调用、数据编/解码、进程上下文切换, 成本相对于单体架构和动态链接库的直接函数调用要高一些, 所以需要谨慎控制通信的次数.
服务 系统架构中最强的边界形式就是服务.</description></item><item><title>架构整洁之道 --- 基础准备篇</title><link>//lyn-euler.github.io/posts/2019_12_27-%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E4%B8%8A-%E5%9F%BA%E7%A1%80%E5%87%86%E5%A4%87%E7%AF%87.html</link><pubDate>Fri, 27 Dec 2019 00:00:00 +0000</pubDate><guid>//lyn-euler.github.io/posts/2019_12_27-%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E4%B8%8A-%E5%9F%BA%E7%A1%80%E5%87%86%E5%A4%87%E7%AF%87.html</guid><description>架构一词相信很多技术开发的同学在工作中经常接触到, 甚至于不少同学在求职简历中介绍自己工作的内容有不少也写着譬如架构改进相关的术语. 但对于架构的工作理论知识却知之甚少, 更多的还停留在“构造文件夹”的层面. 在阅读本文之前我们不妨来尝试回答一下问题.
什么是你理解的架构, 架构的价值在哪里. 你简历中的架构改进, 主要做了哪些工作. 你知道哪些架构模式, 有哪些架构设计中的原则, 你在做架构设计的时候是如何进行的. 分层架构里你通过什么去界定每一层. 这个系列将通过介绍架构相关的知识, 来尝试性给这些问题提供回答的方向.
基础准备篇 架构模式篇 下面是准备篇的内容 什么是软件架构 **架构（architecture）**一词大概是源于建筑学，也常指建筑物在其尺度上是如何依靠内部的支撑物相互结合而稳固构造的方式。 **软件架构（software architecture）**是一系列相关的抽象模式，用于指导大型软件系统各个方面的设计. 而广义的理解这里的抽象模式不仅仅只是技术的选型, 框架的输出. 它应该是贯穿在整个问题解决方案的方方面面, 包括对技术的组织, 业务的组织, 资源(包括人员)的组织. 本文下面所有的&amp;quot;架构&amp;quot;一词不做特殊说明都是指软件架构中对系统或工程的组织.
软件架构的价值和目标 既然要聊是软件架构的价值, 那首先我们要了解软件系统的价值所在. 软件(Software)的价值有两方面:行为价值(表现)和架构价值(结构). 这也是对 software 这个词的拆解:
行为价值 ware表示商品, 也就是软件所表现出的商品属性. 也就是软件的表现, 包括需求的实现, 以及可用性保障(性能、功能可用性等). 架构价值 soft 表示软件的结构可扩展易修改属性. 可以从两方面理解 当利益相关者想要改一个需求，所需的软件变更必须简单方便; 变更实施的难度应该和变更的范畴（scope）成等比，而与变更的具体形状（shape）无关. 在我看来这两个价值关系就像“鹅与金蛋”的关系: 行为价值代表着‘产量’, 决定了利益相关者的实际收益; 架构价值代表‘产能’, 它为行为价值提供支撑, 提升软件系统的服务能力和生产效率. 在实际生产中关键是找准两者的平衡点, 平衡点是对投入产出比的考量、对现有资源的妥协, 而这本身也是架构工作的一部分. 至于架构的目标就是为了实现架构的价值, 通俗的讲就是用更少的资源构建软件系统实现需求(它应该贯穿于软件系统的开发、部署、运行、维护等整个生命周期).而一般情况下, 我们为软件构建中层结构的主要目标
使软件可容忍被改动 使软件更容易理解 构建可在多个软件系统中复用的组件 一个软件架构的优劣, 可以用它满足用户需求所需要的成本来衡量.</description></item><item><title>DYLD-符号绑定</title><link>//lyn-euler.github.io/posts/2020_08_01-dyld-symbol-binding.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>//lyn-euler.github.io/posts/2020_08_01-dyld-symbol-binding.html</guid><description>系统环境
&amp;gt; ProductName: macOS &amp;gt; ProductVersion: 11.0 &amp;gt; BuildVersion: 20A5343i &amp;gt; Darwin Kernel Version 20.0.0: Thu Jul 30 22:49:28 PDT 2020; root:xnu-7195.0.0.141.5~1/RELEASE_X86_64 x86_64 引子 在软件工程的鸿蒙时代, 一个程序的所有源码都是在一个文件上的, 随着工程的扩大和代码量增加, 多人协同、代码复用、维护、编译时间等问题就日益突出了. 为了解决这些问题也就有了静态链接. 但是静态链接也还是存在着很多问题.比如典型的:空间浪费(包括内存和硬盘)、程序更新&amp;amp;部署不方便等.
动态链接的出现使得程序可以在运行时才进行链接, 很好的解决了上述问题. 动态链接的好处有很多，其中包括:
代码重用 常用的代码可以被提取到一个库中，然后共享使用。 易于更新 只要符号大体相同(API接口不变)，驻留在库中的代码可以很容易地更新，库也可以被替换。 减少磁盘使用量 因为动态库中的代码并不会在每一个使用它的二进制中都要包含, 只有在程序运行时才会被链接到可执行文件中, 而不同的程序可以共享同一个动态库代码。 减少RAM的使用 这是它最重要的优势。一个库的副本可能会被mmap-ed到所有的进程中，而在RAM中实际只占用一次。库代码通常被标记为r-x(只读可执行)，因此同一个物理副本被许多进程隐含地共享。 注: 同时动态链接的运行时特性赋予了我们很重要的能力&amp;ndash;函数拦截、审计和HOOK。dyld允许通过环境变量&amp;ndash;DYLD_INSERT_LIBRARIES(类似于ld的LD_PRELOAD)和DYLD_LIBRARY_PATH(类似于ld的LD_LIBRARY_PATH)&amp;ndash;以及它的函数插值机制来实现HOOK和拦截; 此外你还可以直接通过修改符号表等来实现类似功能.后续可以单独开篇来讲解这方面的应用.
准备 因为整个符号绑定的流程比涉及面比较广, 在开始具体流程分析之前, 可能需要掌握一些准备知识和了解专业术语.
基本概念 Mach-O: Mach-O为Mach Object文件格式的缩写，它是一种用于可执行文件，目标代码， 动态库，内核转储的文件格式, 包括文中提及的镜像也是一种Mach-O文件.
dyld: Apple 生态操作系统（macOS、iOS）的动态链接器.
dylib: 动态库. 类似于Unix中的Shared Object。一个 MH_DYLIB (0x6)类型的Mach-O对象，通过LC_LOAD_DYLIB Mach-O命令或 dlopen API加载到其他可执行文件中。</description></item><item><title>elements</title><link>//lyn-euler.github.io/elements.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>//lyn-euler.github.io/elements.html</guid><description>Table of contents Table of contents Text Code Python C/C++ Bash Tables Text Some example text
Code Python def foo(): print (&amp;#34;This is a python function&amp;#34;) C/C++ void foo(){ prinf(&amp;#34;%s\n&amp;#34;, &amp;#34;This is a C function&amp;#34;) } Bash # This is a bash command cd dir &amp;amp;&amp;amp; echo $PWD; # Return exit 0; Tables Pages Elements 1 Text 2 Code 3 Tables</description></item><item><title>ld64</title><link>//lyn-euler.github.io/posts/2020_07_01-ld.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>//lyn-euler.github.io/posts/2020_07_01-ld.html</guid><description>本文基于ld版本
&amp;gt; @(#)PROGRAM:ld PROJECT:ld64-609 &amp;gt; BUILD 07:59:13 Aug 25 2020 &amp;gt; configured to support archs: armv6 armv7 armv7s arm64 arm64e arm64_32 i386 x86_64 x86_64h armv6m armv7k armv7m armv7em LTO support using: LLVM version 12.0.0, (clang-1200.0.32.2) (static support for 27, runtime is 27) TAPI support using: Apple TAPI version 12.0.0 (tapi-1200.0.23) 简介 ld files... [options] [-o outputfile] 描述 ld命令将多个对象文件和库结合起来，解析引用，并产生一个输出文件。ld可以产生一个最终的链接镜像(可执行文件、dylib或bundle)，或者使用-r选项，产生一个 另一个object file。 如果不使用-o选项，产生的输出文件被命名为 &amp;ldquo;a.out&amp;rdquo;。
通用 链接器接受通用（多架构）输入文件，但总是创建一个 &amp;ldquo;thin&amp;rdquo;（单架构）的标准Mach-O输出文件。 输出文件的体系结构是通过使用 -arch 选项确定的。 如果不使用这个选项，ld会尝试通过按命令行顺序检查对象文件来确定输出架构。 第一个 &amp;ldquo;thin&amp;quot;架构决定了输出的文件。 如果没有输入对象文件是 &amp;ldquo;thin&amp;quot;文件，则使用主机的原生32位架构。</description></item><item><title>WWDC20-OC runtime改进</title><link>//lyn-euler.github.io/posts/-2020_06_28-wwdc20-objective-c-runtime-%E6%94%B9%E8%BF%9B.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>//lyn-euler.github.io/posts/-2020_06_28-wwdc20-objective-c-runtime-%E6%94%B9%E8%BF%9B.html</guid><description>类结构体变化 在你的应用程序的磁盘上，二进制类是这样的. 首先是类对象本身，它包含了最常被访问的信息：指向元类、超类和方法缓存的指针.它还有一个指向更多数据的指针.存储额外信息的地方叫做 class_ro_t.RO代表只读，该结构体包括像类名，方法、协议和实例变量的信息. Swift类和Objective-C类共享这个基础架构，所以每个Swift类也有这些数据结构.当类第一次从磁盘加载到内存中时，它们一开始也是这样的.但是一旦使用了它们，它们就会发生变化. 在阐述具体发生什么之前先了解两个概念:
Clean Memory: 是指一旦加载后就不会改变的内存 比如class_ro_t就是clean的, 因为它是只读的.
Dirty Memory: 脏内存是指在进程运行时被改变的内存 类结构一旦被使用，就会被弄脏，因为运行时会向它写入新的数据(例如它创建了一个新的方法缓存，并从类中指向它). Dirty Memory 要比 Clean Memory 昂贵的多, 因为只有进程在运行，它就必须一直存在; 而Clean Memory是不变的, 如果需要系统能从磁盘中重新加载它, 所以可以从内存中移除. MacOS 中有swap脏内存的可选操作, 但是因为iOS没有使用swap,脏内存在iOS中的代价会特别大.出于这个原因,能保持干净的数据越多越好, 原来的类结构体被划分为两块.通过分离出那些永远不会改变的数据，那就可以把大部分的类数据作为干净的内存来保存. 这些数据足以让我们开始使用，但运行时需要跟踪每个类的更多信息, 所以，当一个类第一次被使用时，运行时会为它分配额外的存储空间. 这个运行时分配的存储是可读可写的数据class_rw_t.在这个数据结构中，我们存储了只有在运行时产生的新信息.例如，所有的类都会使用这些First Subclass和Next Sibling Class指针链接成一个树形结构. 而且这允许运行时遍历当前使用的所有类，这对于无效的方法缓存很有用.但是，既然方法和属性也在只读数据中，为什么我们要在这里有方法和属性呢？嗯，因为它们可以在运行时改变.当一个Category被加载时，它可以向类中添加新的方法.而且程序员可以使用运行时API动态添加它们.由于class_ro_t是只读的，所以我们需要在class_rw_t中跟踪这些东西. 现在发现，这样做会占用不少的内存.在任何一个给定的设备中，都有很多类在使用.我们在一台iPhone上测得整个系统中大约有30MB的这些class_rw_t结构. 那么我们如何才能缩小这些呢？请记住，我们在读/写部分都需要这部分数据，因为它们可以在运行时改变.但是&amp;hellip;&amp;hellip;检查实际设备上的使用情况，苹果发现只有10%左右的类真正改变过它们的方法.而且这个Demangled Name字段只有Swift类才会使用，除非有东西询问他们的Objective-C名称，否则Swift类也根本不需要它.所以，我们可以把那些平时不用的部分拆掉. 这样一来，class_rw_t的大小就减少了一半.对于那些确实需要额外信息的类，我们可以分配一个这样的扩展记录，然后把它滑到类中供其使用.大约90%的类从来不需要这些扩展数据，整个系统节省了大约14MB.这些内存现在可以用于更有成效的用途，比如存储你的应用程序的数据. 因此，你可以通过在终端中运行一些简单的命令，亲自在 Mac 上看到这一变化的影响.
# note:确认对应的App在运行 heap Mail | egrep &amp;#39;class_rw|COUNT&amp;#39; 而从返回的结果中，我们可以看到，我们在邮件应用中使用了大约9000个这样的class_rw_t类型，但实际上其中只有大约十分之一，900多一点，需要使用这个扩展信息. 单邮件这一个应用我们就节省了大约25万兆的数据. 如果我们在系统范围内进行扩展，那就真正能节省了很多脏内存带来的开销. 修改之后很多从类中获取数据的代码必须同时处理那些有和没有扩展数据的类.当然，因为读取和更新这些结构的代码都在runtime内, runtime内部会为你处理所有这些操作，从外部看一切都像以前一样，只是使用更少的内存. 所以尽量使用runtime提供的API，因为这部分数据结构的更改, 任何第三方试图直接访问这些数据结构的代码在今年的操作系统版本中都会停止工作.
方法列表变化 接下来，让我们再深入了解一下这些类的数据结构，看看另一个变化：相对方法列表(relative method lists).每个类都有一个附加的方法列表.当你在一个类上写一个新方法时，它就会被添加到列表中.runtime使用这些列表来解析消息发送. 每个方法都包含三条信息: 首先是方法的名称，或者说Selector;Selector是字符串，但它们是唯一的，所以它们可以使用指针平等来比较. 其次是方法的类型编码(type encoding).</description></item><item><title>xcode编译耗时优化</title><link>//lyn-euler.github.io/posts/2020_06_13%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%B8%A6%E8%96%AA%E7%BC%96%E8%AF%91%E7%9A%84%E6%97%B6%E9%97%B4.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>//lyn-euler.github.io/posts/2020_06_13%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%B8%A6%E8%96%AA%E7%BC%96%E8%AF%91%E7%9A%84%E6%97%B6%E9%97%B4.html</guid><description>前戏太长, 容易疲软. 几乎每一个iOSer都会时不时地遭受Xcode构建时间过长的困扰. 它直接导致生产率的降低，并拖慢了整个团队的开发进程, 影响coding辛福感. 跟做app性能提升类似, 优化编译时间在很大程度上需要的是耐心、严谨和毅力，要仔细、持续地测量. 是一个逐步消除噪音，集中精力去分析一个信号的过程.
环境配置 Apple Swift version 5.2.4 (swiftlang-1103.0.32.9 clang-1103.0.32.53) Target: x86_64-apple-darwin19.5.0
量化 在开始之前先来看看如何量化这部分的数据. 一方面这些数据帮助我们更精确地度量优化的效果,集中精力focus具体的可优化项; 另一方面或许你的晋升或KPI总结里需要这部分内容.
直接查看Report Navigator中的日志, 是获取总的编译耗时最直接简单的方式. 另外也可以通过配置ShowBuildOperationDuration来开启activity viewer中的编译耗时视图
defaults write com.apple.dt.Xcode ShowBuildOperationDuration YES 当然这只能查看单个总耗时, 如果需要粒度更细的数据可以使用 Product-&amp;gt;Perform Action-&amp;gt;Build With Timing Summary编译工程(好像并没用), 或者添加命令行编译参数-showBuildTimingSummary
xcodebuild -project &amp;#39;xxx.xcodeproj&amp;#39; \ -scheme &amp;#39;xxx&amp;#39; \ -configuration &amp;#39;Debug&amp;#39; \ -sdk &amp;#39;iphonesimulator&amp;#39; \ -showBuildTimingSummary \ clean build 这样就可以获取每个阶段的耗时了, 然后针对每个耗时较长的阶段进行优化.
Build Timing Summary CompileSwiftSources (4 tasks) | 141.</description></item></channel></rss>