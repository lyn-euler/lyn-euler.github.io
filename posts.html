<!doctype html><html><head><title>Posts</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,user-scalable=no"><link rel=stylesheet href=./assets/css/main.css><noscript><link rel=stylesheet href=./assets/css/noscript.css></noscript><style>:root{--site-background: url("/images/bg.jpg")}</style><script src=https://identity.netlify.com/v1/netlify-identity-widget.js></script></head><body class=is-preload><div id=wrapper><header id=header><div class=logo><a href=./><span class="icon fa-flag"></span></a></div><div class=content><div class=inner><h1>Posts</h1><p>A collection of posts</p></div></div><nav><ul><li><a href=#rflmrc3nrkblj7fnu5hlrpo>DYLD-符号绑定</a></li><li><a href=#ld64>ld64</a></li><li><a href=#v1deqziwlu9dihj1bnrpbwxmllnov5s>WWDC20-OC runtime改进</a></li><li><a href=#egnvzgxnvjbor5hogjfml7bkvjjljjy>xcode编译耗时优化</a></li><li><a href=#5p625p6e5pw05rsb5lml6ygtic0tlsdln7rnoydlh4blpifnr4c>架构整洁之道 --- 基础准备篇</a></li><li><a href=#5p625p6e5pw05rsb5lml6ygtls3ovrnnlyw>架构整洁之道--边界</a></li></ul></nav></header><div id=main><article id=5p625p6e5pw05rsb5lml6ygtls3ovrnnlyw><h2 class=major>架构整洁之道--边界</h2><span class="image main"><img src alt></span><p>上一篇<a href=https://mp.weixin.qq.com/s/B6npSrKHQbK1u7PX2gPPXg>《架构整洁之道(上) &mdash; 基础准备篇》</a>中我们介绍了架构的一些基本概念和设计原则, 最后还学习了关于组件构建的一些原则. 这一篇我们来讲讲组件的边界划分.</p><h2 id=边界>边界</h2><p>正如上一篇提到过的, 软件架构所追求的目标是最大限度地降低构建和维护一个系统所需的资源. 而这其中最消耗我们人力资源的又是什么? 答案是系统中存在的耦合 &mdash; 尤其是那些过早作出的不成熟的决策所导致的耦合. 也就是那些和系统的业务需求(用例除外)无关的决策, 包括我们要采用的框架、数据库、Web服务器、工具库、依赖注入等.
在一个设计良好的系统架构中, 这些细节性的决策都应该是辅助性且可被推迟的, <strong>我们的架构设计不应该依赖于这些细节, 而要尽可能的推迟这些细节性的决策, 并致力于将这种推迟所产生的影响降到最低</strong>.
所以如何将软件分割成各种元素, 以便约束元素之间的依赖关系就尤为重要了. 而边界的作用就在于此. 可以说软件架构设计的本身就是一门划分边界的艺术.
所谓的<strong>边界划分</strong>, 就是指在组件间建立变更的防火墙. 我们称在运行时, 一个组件调用另一个组件的函数并传递数据(或者说边界两侧函数调用和数据传递)的行为为<strong>跨边界调用</strong>.由于一个组件的源码变更会导致其他组件的源码也有可能会随之发生变更和重新编译, 所以要处理好跨边界调用就需要对源码中的依赖关系进行合理管控.</p><h2 id=边界的形式>边界的形式</h2><p>一个系统的架构是有组件以及他们之间的边界共同定义的. 那么这些边界又有哪些存在的形式呢?</p><h3 id=源码层次上的解耦模式>源码层次上的解耦模式</h3><p>最简单、最常见的架构边界通常并没有一个固定的物理形式, 他们只是对一个进程、同一个地址空间内的函数和数据进行某种划分, 也就是源码层次上的解耦模式. 从部署角度看, 最后都产生了一个单独的可执行文件&mdash;也就是所谓的单体结构.
这类架构一般都需要利用某种动态形式的多态来管理其内部的依赖关系(这也是面向对象编程这类编程范式进几十年来一直是主流的原因).最简单的跨边界调用是由低层客户端来调用高层服务函数, 这种依赖关系在运行时和编译时都会保持一致.</p><p><img src=./15792294473686/15794082412678.jpg alt></p><p>但当高层组件的客户端需要调用底层组件的服务时, 我们就需要运用动态形式的多态来反转依赖关系了. 这种情况下, 运行时和编译的依赖关系就是相反的.</p><p><img src=./15792294473686/15794088699998.jpg alt></p><p>这种自律的组件划分可以极大地帮助整个项目的开发、测试和部署, 使不同团队可以同时开发不同的组件不会相互干扰. 高层组件与低层细节之间也可以得到良好的隔离, 独立演进.</p><h3 id=部署层次的解耦模式>部署层次的解耦模式</h3><p>与单体架构类似, 其所有的函数仍然处于同一个进程、同一个地址空间中. 管理组件划分依赖关系的策略也基本一致. 不同的是这种模式将其所有可部署的单元打包成一个便于操作的文件格式, 不需要重新编译就可以交付的形式(二进制或其他等价的可部署形式), 比如最常见的物理边界形式&mdash;动态链接库.</p><h3 id=本地进程>本地进程</h3><p>系统架构还有一个更明显的物理边界形式:本地进程. 每个本地进程既可以是一个静态链接的单体结构 也可以是由多个动态链接组件构成的程序. 我们可以将本地进程看成膜中超级组件, 该进程由一系列的较低层次的组件组成, 我们将通过动态形式的多态来管理他们之间的依赖关系, 本地进程的隔离策略也与单体结构和动态链接库基本相同, 其源码中的依赖关系也是始终由低层组件指向高层策略. 对本地进程来说, 高层进程的源码中不应该包含低层进程的名字、物理内存地址或注册表键名. 应该让低层进程成为高层进程的一个插件.
本地进程跨边界调用需要用到系统调用、数据编/解码、进程上下文切换, 成本相对于单体架构和动态链接库的直接函数调用要高一些, 所以需要谨慎控制通信的次数.</p><h3 id=服务>服务</h3><p>系统架构中最强的边界形式就是服务. 服务可以是一个进程, 通常由命令行环境或其他等价的系统调用来生成. 但服务并不依赖于具体的运行为主, 两个相互通信的服务可以处于单一物理处理器/多喝系统的同一组处理器上, 也可以处于不同处理器上.
与本地进程类似我们在划分架构边界的时候, 应让低层次的服务作为高层次服务的插件, 确保高层次的服务源码中没有包含任何低层服务相关的物理信息(URI等).</p><p>无论服务还是本地进程, 他们都是由一个或多个源码组件组成的单体结构, 或者一组动态链接的可部署组件, 这也就意味着系统通常会同时包含高通信量、低延迟的本地架构边界; 和低通信量、高延迟的服务边界.</p><h4 id=服务化的问题>服务化的问题</h4><p>无论从系统架构的意义还是通过服务化这种形式隔离不同平台/进程中的程序行为都是一件重要的事情, 但这并不意味着我们应该服务化就是”银弹“, 也不意味着服务化本身没有问题.在极端情况下, 客户端和服务端甚至可能会由于耦合过于紧密而不具备系统架构意义上的隔离性.</p><h5 id=解耦的谬论>解耦的谬论</h5><p>很多时候我们在讨论服务化的好处的时候, 都在强调它将系统拆分后实现了强解耦. 从一定程度上讲是的, 毕竟每个服务都是以不同进程/不同处理器/物理机来运行, 彼此不能直接访问服务间的变量; 然而, 他们之间还是可能会有处理器内地共享资源, 或通过网络共享的资源而彼此耦合. 而任何形式的共享数据行为都会导致强耦合.
例如: 如果给服务间传递的数据结构中新增一个字段, 那么每个操作之歌字段的服务就必须作出更改, 服务之间必须对这条数据的解读达成一致.这里的服务就强耦合于这条数据结构.
而服务的接口与普通函数接口相比, 并没有比后者更正式、更严谨和更好.</p><h5 id=独立部署的谬论>独立部署的谬论</h5><p>我们在吹嘘服务化的好处时另一个通常会说的是, 不同服务可以由不同的专职团队负责和运维.这让团队可以采用dev-ops 混合的形式来编写和维护或运维各自的服务.这种开发和部署上的独立性可以被认为是可扩展的.
但是抛开大型系统可以同样采用单体或组件模式来构建外, 我们上面说过拆分服务并不意味着这些服务就可以彼此独立, 如果这些服务之间以数据或行为形式相耦合那么他们的开发、部署、和运维也必须彼此协调来进行.</p><h2 id=不完全边界>不完全边界</h2><p>构建完整的架构边界是一件很耗时耗力的事. 在这个过程中需要为系统设计双向的多态边界接口, 用于输入和输出的数据结构以及相关的依赖关系管理. 这里会涉及大量的前期工作和后期维护工作.而一位优秀的架构师在认识设计架构边界成本太高后, 为了将来的可能需要, 通常还是会希望预留一个边界. 即便这种预防性的实际违背了<code>YAGNI</code>(You Aren&rsquo;t Going to Need It)原则, 而被敏捷社区所诟病. 然而架构的工作本身就咬做这样的预见性设计, 这时候, 我们就需要引入不完全边界(partial boundary).</p><h3 id=省略多组件的管理部分>省略多组件的管理部分</h3><p>简单的说这种方式就是将系统分割成一系列可以独立编译、独立部署的组件后, 再把他们构建成一个组件. 显然这种不完全边界所需的代码量和设计工作, 和设计完整的边界时是完全一样的. 它只是省去了多组件管理这部分的工作(包括版本号管理、发布管理等).</p><h3 id=单向边界>单向边界</h3><p>在设计一套完整的系统架构边界时, 往往需要反向接口来维护边界两侧组件的隔离性. 而且这一般不是一次性工作, 需要我们持续长期的投入.
而单向边界就是用临时的占位、将来可被替换成完整架构边界的单向边界设计, 简单来说就是完整边界设计的部分实现. 由于没有采用双向反向设计, 这部分只能依赖开发者和架构师的自律来保证组件的持久隔离性.</p><h3 id=门户模式>门户模式</h3><p>还有一种更简单的架构边界设计: *门户模式(facade pattern).*这种模式下我们连依赖反转的工作都可以省略. 这里的边界都只能由Facade类来定义, 它会负责将 Client 的调用传递给 Client 不可见的服务函数.</p><p><img src=./15792294473686/15794189255184.jpg alt=-w510></p><h2 id=测试边界>测试边界</h2><p>和程序代码一样, 测试代码也是系统的一部分.本质说, 测试组件也是要遵循依赖关系原则的, 它始终是内向依赖于被测试部分的代码的, 同时系统中没有其他组件依赖于它们. 另一方面, 测试组件也是可以独立部署(事实上大部分测试组件都被部署在测试环境, 而在生产环境中剥离).</p><h3 id=脆弱的测试问题>脆弱的测试问题</h3><p>由于测试代码与系统是强耦合的, 它就随着系统的变更而变更. 哪怕系统中组件的一点小变化, 都可能导致许多与之相耦合的测试出现问题, 需要作出相应的变更. 而严重的情况, 修改一个通用的系统组件可能导致成百上千的测试除夕问题, 我们通常成这类问题为<em>脆弱的测试问题(fragile tests problem).</em> 而这类问题往往还会让系统变的非常死板. 当开发者意识到一些简单的修改会导致大量的测试出错的时候, 他们自然就会抵制修改.
要想解决这个问题, 就必须在设计中考虑到系统的可测试性. 软件设计的第一条原则(不管是未来可测试性还是其他)是不变的: 不要依赖于多变的东西. 譬如GUI是多变的, 我们在系统设计的时候应该让业务逻辑不通过GUI也可以被测试.为测试建立专门验证业务逻辑的测试创建一个API.</p><p><img src=./15792294473686/qrcode_for_gh_404a709698ca_258.png alt=qrcode_for_gh_404a709698ca_258></p></article><article id=5p625p6e5pw05rsb5lml6ygtic0tlsdln7rnoydlh4blpifnr4c><h2 class=major>架构整洁之道 --- 基础准备篇</h2><span class="image main"><img src alt></span><p>架构一词相信很多技术开发的同学在工作中经常接触到, 甚至于不少同学在求职简历中介绍自己工作的内容有不少也写着譬如<code>架构改进</code>相关的术语. 但对于架构的工作理论知识却知之甚少, 更多的还停留在“构造文件夹”的层面. 在阅读本文之前我们不妨来尝试回答一下问题.</p><ul><li>什么是你理解的架构, 架构的价值在哪里.</li><li>你简历中的架构改进, 主要做了哪些工作.</li><li>你知道哪些架构模式, 有哪些架构设计中的原则, 你在做架构设计的时候是如何进行的.</li><li>分层架构里你通过什么去界定每一层.</li></ul><p>这个系列将通过介绍架构相关的知识, 来尝试性给这些问题提供回答的方向.</p><ul><li><a href=#>基础准备篇</a></li><li><a href>架构模式篇</a></li></ul><p>下面是准备篇的内容
<img src=./15772357560520/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84.png alt=目录-w400></p><h2 id=什么是软件架构>什么是软件架构</h2><p>**架构（architecture）**一词大概是源于建筑学，也常指建筑物在其尺度上是如何依靠内部的支撑物相互结合而稳固构造的方式。
**软件架构（software architecture）**是一系列相关的抽象模式，用于指导大型软件系统各个方面的设计. 而广义的理解这里的抽象模式不仅仅只是技术的选型, 框架的输出. 它应该是贯穿在整个问题解决方案的方方面面, 包括对技术的组织, 业务的组织, 资源(包括人员)的组织. 本文下面所有的"架构"一词不做特殊说明都是指软件架构中对系统或工程的组织.</p><h2 id=软件架构的价值和目标>软件架构的价值和目标</h2><p>既然要聊是软件架构的价值, 那首先我们要了解软件系统的价值所在. 软件(Software)的价值有两方面:<strong>行为价值</strong>(表现)和<strong>架构价值</strong>(结构). 这也是对 <code>software</code> 这个词的拆解:</p><ul><li>行为价值
<code>ware</code>表示商品, 也就是软件所表现出的商品属性. 也就是软件的表现, 包括需求的实现, 以及可用性保障(性能、功能可用性等).</li><li>架构价值
<code>soft</code> 表示软件的结构可扩展易修改属性. 可以从两方面理解<ol><li>当利益相关者想要改一个需求，所需的软件变更必须简单方便;</li><li>变更实施的难度应该和变更的范畴（scope）成等比，而与变更的具体形状（shape）无关.</li></ol></li></ul><p>在我看来这两个价值关系就像“鹅与金蛋”的关系: 行为价值代表着‘产量’, 决定了利益相关者的实际收益; 架构价值代表‘产能’, 它为行为价值提供支撑, 提升软件系统的服务能力和生产效率. 在实际生产中关键是找准两者的平衡点, 平衡点是对投入产出比的考量、对现有资源的妥协, 而这本身也是架构工作的一部分.
至于架构的目标就是为了实现架构的价值, 通俗的讲就是用更少的资源构建软件系统实现需求(它应该贯穿于软件系统的开发、部署、运行、维护等整个生命周期).而一般情况下, 我们为软件构建中层结构的主要目标</p><ul><li>使软件可容忍被改动</li><li>使软件更容易理解</li><li>构建可在多个软件系统中复用的组件</li></ul><p>一个软件架构的优劣, 可以用它满足用户需求所需要的成本来衡量. 如果在系统的整个生命周期内一直维持低成本, 那么这个系统设计就是优良的. 那么我们应该如何设计一个优良的架构呢?</p><h2 id=好的架构从代码开始>好的架构从代码开始</h2><p>任何软件架构的实现都依赖于具体的代码, 所以要想构建好的软件系统, 应该从整洁的代码开始.
毕竟建筑设计的再好, 如果使用的砖头质量不好, 架构能起到的作用也是微乎其微的. 同时如何组织这些砖头也很大程度上决定了建筑的整体质量. 在软件编程领域<code>编程范式</code>和<code>SOLID 设计原则</code>给了很好的理论指导和实践基础.</p><h3 id=编程范式>编程范式</h3><p><strong>编程范式 (paradigm)</strong> 指的是程序的编写模式.
其实所谓架构就是限制，限制源码放在哪里、限制依赖、限制通信的方式，但这些限制比较上层。编程范式是最基础的限制，它限制我们的控制流和数据流：</p><ul><li><code>结构化编程</code>对程序控制权的直接转移进行了限制和规范;</li><li><code>面向对象编程</code>对程序控制权的间接转移进行了限制和规范;</li><li><code>函数式编程</code>对程序中的赋值进行了限制和规范;</li></ul><h3 id=solid设计原则>SOLID设计原则</h3><p>SOLID原则的主要作用就是告诉我们如何将数据和函数组织成为类(这里的类区别于面向对象编程中的类, 它代表了一种数据和函数的分组),以及如何建这些累链接起来成为程序.</p><ul><li><p><strong>单一职责原则(SRP)</strong>
任何一个软件模块都应该只对某一类行为负责. 该设计是基于康威定律(Conway&rsquo;s Law)的一个推论 &mdash; 一个软件系统的最佳结构高度依赖于开发这个系统的组织内部结构.</p></li><li><p><strong>开闭原则(OCP)</strong>
设计良好的计算机软件应该易于扩展, 同时抗拒修改.</p></li><li><p><strong>里氏替换原则(LSP)</strong>
如果想用可替换的组件来构建软件系统, 那么这些组件必须遵循同一个约定, 以便让这些组件可以相互替换.</p></li><li><p><strong>接口隔离原则(ISP)</strong>
该设计原则主要告诫软件设计师应该在设计中避免不必要的依赖.</p></li><li><p><strong>依赖反转原则(DIP)</strong>
该设计原则指出高层策略性的代码不应该依赖底层实现细节, 相反实现底层细节的代码应该依赖高层策略性代码.</p></li></ul><h3 id=组件构建原则>组件构建原则</h3><p>当然, 正如一块好砖也会盖歪楼一样, 采用良好的中层组件并不能保障系统的整体运作良好. 所以有必要再针对组件的设计原则进一步的讨论. 如果说SOLID原则是指导我们如何将砖砌成墙和房间, 那么组件构建原则就是指导我们如何将这些房间组合成房子.</p><h4 id=组件聚合>组件聚合</h4><p>那么哪些类应该被合成一个组件? 这是一个非常重要的设计决策 应该遵循优秀的软件工程经验, 下面介绍三个与构建组件相关的基本原则:</p><ul><li><p><strong>复用/发布等同原则(REP)</strong>
软件复用的最小力度应等同于其发布的最小粒度.</p></li><li><p><strong>共同闭包原则(CCP)</strong>
我们应该将哪些会同时修改, 并且为相同目的而修改的类放到一个组件中, 而将不同时修改或不会为了相同目的而修改的类放到不同组件中.</p></li><li><p><strong>共同复用原则(CRP)</strong>
不要强迫一个组件的用户依赖他们不需要的东西.</p></li></ul><p>仔细的读者大概已经意识到这三个原则之前是存在竞争的关系. <code>REP</code> 和 <code>CCP</code> 原则是粘合性原则, 而 <code>CRP</code> 原则是排除性原则. 架构的工作就要在这三个原则中进行取舍, 优秀的架构师应该在这三角区域中定位一个最适合当前研发团队的位置, 同时根据时间和实际情况不停调整. 组件的构成安排应该随着项目重心的不同, 以及研发性和复用性的不同而不断演化.
<img src=./15772357560520/2509688-6782d4674ddb5416.png alt=2509688-6782d4674ddb5416></p><h4 id=组件耦合>组件耦合</h4><p>按上面的原则类被合成一个个组件, 那么组件间的关系又该如何处理.</p><ul><li><p><strong>无依赖环原则</strong>
组件依赖关系图中不应该出现环.
针对<code>每周构建</code>中通过频繁的构建影响高效率开发, 延长构建时间间隔影响项目质量, 增大风险的情景, 通过独立组件发布可以消除影响, 但必须保障组件间没有依赖环. 可以通过<strong>依赖反转原则<code>DIP</code><strong>和</strong>创建共同依赖的新组件</strong>的方式来解决.</p></li><li><p><strong>稳定依赖原则(SDP)</strong>
依赖关系必须要指向更稳定的方向.
这里组件的稳定性指的是它的变更成本，和它变更的频繁度没有直接的关联(变更的频繁程度与需求的稳定性更加相关). 那么, 如何衡量一个组件的稳定性呢? 其中一种方法是计算所有入和出的依赖关系.</p><ol><li><code>入向依赖(Fan-in)</code>这个指标指带了组件内部类的数量.</li><li><code>出向依赖(Fan-out)</code>指代组件内部类依赖于组件外部类的数量.</li><li><code>不稳定性(I)</code> I=Fon-out/(Fan-in + Fon-out).
如果发现违反稳定依赖原则的地方，解决的办法也是通过 <code>DIP</code> 来反转依赖</li></ol></li><li><p><strong>稳定抽象原则(SAP)</strong>
一个组件的抽象化程度应该与其稳定性保持一致.
为了防止业务决策和架构设计经常变更, 我们需要把代表系统高阶决策的组件放到稳定组件中. 然而如果我们这么做, 那么用于秒杀那些策略的源代码就难以修改. 为了防止高阶策略难以修改，根据开闭原则<code>OCP</code>通常我们应该抽象出稳定的接口、抽象类为单独的组件，让具体实现的组件依赖于接口组件，这样它的稳定性就不会影响它的扩展性.
衡量抽象化程度: <code>A=Na/Nc</code> (其中 <em>Nc</em> 代表组件中类的数量, <em>Na</em> 代表组件中抽象类和接口的数量)
将不稳定性（I）作为横轴，抽象程度（A）作为纵轴，那么最稳定、只包含抽象类和接口的组件应该位于左上角（0，1），最不稳定、只包含具体实现类，没有任何接口的组件应该位于右下角（1，0），他们连线就是主序列线，位于线上的组件，他们的稳定性和抽象程度相匹配，是设计良好的组件。位于（0，0）周围区域的组件，它们是非常稳定（注意这里的稳定指的是变更成本）并且非常具体的组件，因为他们的抽象程度低，决定了他们经常改动的命运，但是又有许多其他组件依赖他们，改起来非常痛苦，所以这个区域叫做痛苦区。右上角区域的组件，没有其他组件依赖他们，他们自身的抽象程度又很高，很有可能是陈年的老代码，所以这个区域叫做无用区。
<img src=./15772357560520/2509688-ba960017b35b8e22.png alt=2509688-ba960017b35b8e22>
另外，可以用点距离主序列线的距离 Z 来表示组件是否遵循稳定抽象原则，Z 越大表示组件越违背稳定依赖原则。</p></li></ul><h2 id=参考>参考</h2><p><a href=https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html>The Clean Code Blog</a></p></article><article id=rflmrc3nrkblj7fnu5hlrpo><h2 class=major>DYLD-符号绑定</h2><span class="image main"><img src alt></span><p>系统环境</p><pre><code>&gt; ProductName:	macOS
&gt; ProductVersion:	11.0
&gt; BuildVersion:	20A5343i
&gt; Darwin Kernel Version 20.0.0: Thu Jul 30 22:49:28 PDT 2020; root:xnu-7195.0.0.141.5~1/RELEASE_X86_64 x86_64
</code></pre><h2 id=引子>引子</h2><p>在软件工程的鸿蒙时代, 一个程序的所有源码都是在一个文件上的, 随着工程的扩大和代码量增加, 多人协同、代码复用、维护、编译时间等问题就日益突出了. 为了解决这些问题也就有了静态链接.
但是静态链接也还是存在着很多问题.比如典型的:空间浪费(包括内存和硬盘)、程序更新&部署不方便等.</p><p>动态链接的出现使得程序可以在运行时才进行链接, 很好的解决了上述问题. 动态链接的好处有很多，其中包括:</p><ol><li><strong>代码重用</strong>
常用的代码可以被提取到一个库中，然后共享使用。</li><li><strong>易于更新</strong>
只要符号大体相同(API接口不变)，驻留在库中的代码可以很容易地更新，库也可以被替换。</li><li><strong>减少磁盘使用量</strong>
因为动态库中的代码并不会在每一个使用它的二进制中都要包含, 只有在程序运行时才会被链接到可执行文件中, 而不同的程序可以共享同一个动态库代码。</li><li><strong>减少RAM的使用</strong>
这是它最重要的优势。一个库的副本可能会被mmap-ed到所有的进程中，而在RAM中实际只占用一次。库代码通常被标记为r-x(只读可执行)，因此同一个物理副本被许多进程隐含地共享。</li></ol><p>注: 同时动态链接的运行时特性赋予了我们很重要的能力&ndash;函数拦截、审计和HOOK。dyld允许通过环境变量&ndash;DYLD_INSERT_LIBRARIES(类似于ld的LD_PRELOAD)和DYLD_LIBRARY_PATH(类似于ld的LD_LIBRARY_PATH)&ndash;以及它的函数插值机制来实现HOOK和拦截; 此外你还可以直接通过修改符号表等来实现类似功能.后续可以单独开篇来讲解这方面的应用.</p><h2 id=准备>准备</h2><p>因为整个符号绑定的流程比涉及面比较广, 在开始具体流程分析之前, 可能需要掌握一些准备知识和了解专业术语.</p><h3 id=基本概念>基本概念</h3><ul><li><p><a href=https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/MachOTopics/0-Introduction/introduction.html><strong>Mach-O</strong></a>: Mach-O为Mach Object文件格式的缩写，它是一种用于可执行文件，目标代码， 动态库，内核转储的文件格式, 包括文中提及的镜像也是一种Mach-O文件.</p></li><li><p><strong>dyld</strong>: Apple 生态操作系统（macOS、iOS）的动态链接器.</p></li><li><p><strong>dylib</strong>: 动态库.
类似于Unix中的Shared Object。一个 MH_DYLIB (0x6)类型的Mach-O对象，通过<code>LC_LOAD_DYLIB</code> Mach-O命令或 <code>dlopen</code> API加载到其他可执行文件中。</p></li><li><p><strong>符号(symbol)</strong>: Mach-O文件中的一个变量或函数，在该文件之外可能可见，也可能不可见。</p></li><li><p><strong>Binding(绑定)</strong>: 将一个符号引用和它在内存中的地址连接起来。绑定可以是加载时的，懒惰的（延迟）或（缺失/可覆盖）。这些都可以在编译时控制：ld的 <code>-bind_at_load</code> 指定了加载时绑定，<code>__attribute((weak_import))</code>指定了弱符号。还有一个 ld 的 <code>-prebind switch</code>可以将库预绑定到固定地址.</p></li></ul><h2 id=启动流程>启动流程</h2><p>iOS中冷启动的大致流程如图(dyld2):
<img src=https://raw.githubusercontent.com/lyn-euler/assets/master/img/dyld-lanch.png alt=启动></p><ul><li>内核fork并创建程序进程</li><li>加载程序和依赖的动态库</li><li>Rebase</li><li>Binding</li><li>ObjC runtime 初始化</li><li>其他初始化代码</li></ul><p>dyld3中略有不同增加了缓存以及将解析Mach-O和查找依赖库符号的部分放到了out-of-process进行, 但总体上的流程没有太大变化.
<img src=https://raw.githubusercontent.com/lyn-euler/assets/master/img/dyld3.png alt></p><h2 id=符号binding>符号Binding</h2><p>首先, 我们来创建一个简单的工程看下, 添加以下的代码.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Objective-C data-lang=Objective-C>- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>viewDidLoad</span> {
    NSString <span style=color:#f92672>*</span>name <span style=color:#f92672>=</span> UIApplicationDidFinishLaunchingNotification;
    printf(<span style=color:#e6db74>&#34;%s&#34;</span>, name.UTF8String);
}
</code></pre></div><p>编译后, 可以通过otool工具查看其汇编代码:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ otool -tv dyld-test

dyld-test:
...
<span style=color:#f92672>(</span>__TEXT,__text<span style=color:#f92672>)</span> section
-<span style=color:#f92672>[</span>ViewController viewDidLoad<span style=color:#f92672>]</span>:
0000000100001c60	pushq	%rbp
0000000100001c61	movq	%rsp, %rbp
0000000100001c64	subq	$0x20, %rsp
0000000100001c68	movq	0x2391<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>, %rax <span style=color:#75715e>#_UIApplicationDidFinishLaunchingNotification</span>
0000000100001c6f	movq	%rdi, -0x8<span style=color:#f92672>(</span>%rbp<span style=color:#f92672>)</span>
0000000100001c73	movq	%rsi, -0x10<span style=color:#f92672>(</span>%rbp<span style=color:#f92672>)</span>
0000000100001c77	movq	<span style=color:#f92672>(</span>%rax<span style=color:#f92672>)</span>, %rax
0000000100001c7a	movq	%rax, %rdi
0000000100001c7d	callq	*0x2395<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>        
0000000100001c83	movq	%rax, -0x18<span style=color:#f92672>(</span>%rbp<span style=color:#f92672>)</span>
0000000100001c87	movq	-0x18<span style=color:#f92672>(</span>%rbp<span style=color:#f92672>)</span>, %rax
0000000100001c8b	movq	%rax, %rdi
0000000100001c8e	callq	0x100002382
0000000100001c93	movq	0x7716<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>, %rsi
0000000100001c9a	movq	%rax, %rdi
0000000100001c9d	callq	*0x2365<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>
0000000100001ca3	leaq	0x7ac<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>, %rdi
0000000100001caa	movq	%rax, %rsi
0000000100001cad	movb	$0x0, %al
0000000100001caf	callq	0x100002394 <span style=color:#75715e># call _print_stub</span>
0000000100001cb4	xorl	%ecx, %ecx
0000000100001cb6	movl	%ecx, %esi
0000000100001cb8	leaq	-0x18<span style=color:#f92672>(</span>%rbp<span style=color:#f92672>)</span>, %rdx
0000000100001cbc	movq	%rdx, %rdi
0000000100001cbf	movl	%eax, -0x1c<span style=color:#f92672>(</span>%rbp<span style=color:#f92672>)</span>
0000000100001cc2	callq	0x10000238e
0000000100001cc7	addq	$0x20, %rsp
0000000100001ccb	popq	%rbp
0000000100001ccc	retq
0000000100001ccd	nop
....
</code></pre></div><p>关注上面有备注的两行, 这两行指令分别引用了<code>_UIApplicationDidFinishLaunchingNotification</code>和<code>_print</code>符号. 那么按RIP-relative 寻址方式我们可以计算得到</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>&gt; 0x100001c6f + 0x2391 <span style=color:#f92672>=</span> 0x100004000 <span style=color:#f92672>=</span> _UIApplicationDidFinishLaunchingNotification 目标虚拟地址
&gt; 0x100002394 <span style=color:#f92672>=</span> 0x100001cb4 + 0x6d <span style=color:#f92672>=</span> _print函数目标虚拟地址
</code></pre></div><p>那么<code>0x100001c6f</code>和<code>0x100002394</code>在Mach-O中哪里呢? 通过<code>otool -s</code>或者MachOView我们可以找到这个两个地址分别在<code>__DATA_CONST,__got</code>和<code>__TEXT,__stubs</code> 的section中:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ otool dyld-test -s __DATA_CONST __got
dyld-test:
Contents of <span style=color:#f92672>(</span>__DATA_CONST,__got<span style=color:#f92672>)</span> section
0000000100004000	<span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>
0000000100004010	<span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>
0000000100004020	<span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>

$ otool -v dyld-test -s __TEXT __stubs
dyld-test:
Contents of <span style=color:#f92672>(</span>__TEXT,__stubs<span style=color:#f92672>)</span> section
0000000100002334	jmpq	*0x5cc6<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>
000000010000233a	jmpq	*0x5cc8<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>
0000000100002340	jmpq	*0x5cca<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>
0000000100002346	jmpq	*0x5ccc<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>
000000010000234c	jmpq	*0x5cce<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>
0000000100002352	jmpq	*0x5cd0<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>
0000000100002358	jmpq	*0x5cd2<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>
000000010000235e	jmpq	*0x5cd4<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>
0000000100002364	jmpq	*0x5cd6<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>
000000010000236a	jmpq	*0x5cd8<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>
0000000100002370	jmpq	*0x5cda<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>
0000000100002376	jmpq	*0x5cdc<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>
000000010000237c	jmpq	*0x5cde<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>
0000000100002382	jmpq	*0x5ce0<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>
0000000100002388	jmpq	*0x5ce2<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>
000000010000238e	jmpq	*0x5ce4<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>
0000000100002394	jmpq	*0x5ce6<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>
</code></pre></div><p>实际上, Mach-O中的 <code>__TEXT</code> section对外部符号的引用地址也就是指向这两个section.</p><ul><li><code>__DATA_CONST,__got</code>: no-lazy symbol pointer, 比如全局变量/常量、dyld中的函数符号.</li><li><code>__TEXT,__stubs</code>: lazy symbol stub, 比如其他动态库中的函数符号.</li></ul><h3 id=section__data_const-__got>section(__DATA_CONST __got)</h3><p>可以把<code>section(__DATA_CONST __got)</code>看做一个表, 每个条目是一个地址值.但是上面的结果我们可以看到<code>0x100004000</code>对应的内容都是0.所以dyld需要在运行时用实际的符号地址替换.这也是该section被定义在<code>__DATA</code> segment中的原因了.
那么dyld又是如何获取每个条目的符号信息的呢? 按我的理解至少要该条目的符号名称以及所在的库.
我们知道Mach-O中每个segment都是由<code>LC_SEGMENT</code>定义的, 该命令结束后的阐述描述了section的信息对应的数据结构是:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> section_64 { <span style=color:#75715e>/* for 64-bit architectures */</span>
	<span style=color:#66d9ef>char</span>		sectname[<span style=color:#ae81ff>16</span>];	<span style=color:#75715e>/* name of this section */</span>
	<span style=color:#66d9ef>char</span>		segname[<span style=color:#ae81ff>16</span>];	<span style=color:#75715e>/* segment this section goes in */</span>
	uint64_t	addr;		<span style=color:#75715e>/* memory address of this section */</span>
	uint64_t	size;		<span style=color:#75715e>/* size in bytes of this section */</span>
	uint32_t	offset;		<span style=color:#75715e>/* file offset of this section */</span>
	uint32_t	align;		<span style=color:#75715e>/* section alignment (power of 2) */</span>
	uint32_t	reloff;		<span style=color:#75715e>/* file offset of relocation entries */</span>
	uint32_t	nreloc;		<span style=color:#75715e>/* number of relocation entries */</span>
	uint32_t	flags;		<span style=color:#75715e>/* flags (section type and attributes)*/</span>
	uint32_t	reserved1;	<span style=color:#75715e>/* reserved (for offset or index) */</span>
	uint32_t	reserved2;	<span style=color:#75715e>/* reserved (for count or sizeof) */</span>
	uint32_t	reserved3;	<span style=color:#75715e>/* reserved */</span>
};
</code></pre></div><p>对于<code>__got</code>、<code>__stubs</code>、<code>__la_symbol_ptr</code>这几个 section，该结构体reserved1描述了对应 list 中条目在 [indirect symbol table]
() (下文会讲, 这里就把它看成一个表就好了)中的index.</p><p>还是用上面的程序做例子
<img src=https://raw.githubusercontent.com/lyn-euler/assets/master/img/__got.png alt>
那么<code>__got</code>符号对应indirect symbol table中第17个条目.</p><p>先告一段落, 我们重新回头来看lazy symbol的情况.</p><h3 id=section__text__stubs>section(__TEXT,__stubs)</h3><p>不同于<code>__DATA_CONST, __got</code>, <code>__stubs</code>位于<code>__TEXT</code>段, 所以该内容是不能运行时修改的. 该section的每个表项都是一段汇编代码, 称为<code>符号桩</code>. 比如上面<code>_printf</code>对应的项为:</p><pre><code class=language-armasm data-lang=armasm>0000000100002394	jmpq	*0x5ce6(%rip) 
# 间接寻址, 0x100002394 + 0x5ce6 = 0x100008080
</code></pre><h3 id=section__data__la_symbol_ptr>section(__DATA,__la_symbol_ptr)</h3><p>那么上面 0x100008080 又在哪部分呢?</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ otool -v dyld-test -s __DATA __la_symbol_ptr
dyld-test:
Contents of <span style=color:#f92672>(</span>__DATA,__la_symbol_ptr<span style=color:#f92672>)</span> section
Unknown section type <span style=color:#f92672>(</span>0x00000007<span style=color:#f92672>)</span>
0000000100008000	ac <span style=color:#ae81ff>23</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> 4c <span style=color:#ae81ff>24</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>
0000000100008010	<span style=color:#ae81ff>06</span> <span style=color:#ae81ff>24</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>10</span> <span style=color:#ae81ff>24</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>
0000000100008020	1a <span style=color:#ae81ff>24</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>24</span> <span style=color:#ae81ff>24</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>
0000000100008030	2e <span style=color:#ae81ff>24</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>38</span> <span style=color:#ae81ff>24</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>
0000000100008040	b6 <span style=color:#ae81ff>23</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> c0 <span style=color:#ae81ff>23</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>
0000000100008050	ca <span style=color:#ae81ff>23</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> d4 <span style=color:#ae81ff>23</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>
0000000100008060	de <span style=color:#ae81ff>23</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> e8 <span style=color:#ae81ff>23</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>
0000000100008070	f2 <span style=color:#ae81ff>23</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> fc <span style=color:#ae81ff>23</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>
0000000100008080	<span style=color:#ae81ff>42</span> <span style=color:#ae81ff>24</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>01</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span> <span style=color:#ae81ff>00</span>
</code></pre></div><p>可以看到该地址位于<code>(__DATA,__la_symbol_ptr)</code>中,也就是说符号桩jump的目标地址是0x100002442(小端).</p><h3 id=section__text-__stub_helper>section(__TEXT, __stub_helper)</h3><p>继续查找该地址, 发现位于<code>__TEXT, __stub_helper</code>中</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ otool -v dyld-test -s __TEXT __stub_helper
dyld-test:
Contents of <span style=color:#f92672>(</span>__TEXT,__stub_helper<span style=color:#f92672>)</span> section
000000010000239c	leaq	0x712d<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>, %r11
00000001000023a3	pushq	%r11
00000001000023a5	jmpq	*0x1c75<span style=color:#f92672>(</span>%rip<span style=color:#f92672>)</span>
00000001000023ab	nop
....
0000000100002438	pushq	$0xd2
000000010000243d	jmp	0x10000239c
0000000100002442	pushq	$0x1ca
0000000100002447	jmp	0x10000239c
000000010000244c	pushq	$0x19
0000000100002451	jmp	0x10000239c
</code></pre></div><p>可以看到这段代码的执行流程 0000000100002442 -> ..-> 000000010000239c -> ..-> 00000001000023a5. 最终执行:</p><pre><code class=language-armasm data-lang=armasm>00000001000023a5 jmpq	*0x1c75(%rip)
00000001000023ab	nop
# 0x1c75 + 0x1000023ab = 0x100004020
</code></pre><p>继续查找<code>0x100004020</code>发现位于<code>__DATA_CONST,__got</code>中, 跟上面分析no-lazy symbol一样, 最终indirect symbol table中. 其实所有的 lazy 函数符号在dyld初始化后, 都是指向dyld_stub_binder函数.</p><h3 id=__linkedit>__LINKEDIT</h3><p>从OS X 10.5或10.6开始，苹果决定在Mach-O文件中实现一个特殊的段，供DYLD使用。这个段，传统上称为<code>__LINKEDIT</code>，由DYLD在链接和绑定符号的过程中使用的信息组成。上面提到的<code>indirect symbol table</code>就位于这一部分.
LC_SEGMENT定义了该segment, DYLD依靠一个特殊的加载命令LC_DYLD_INFO_ONLY来作为段的 &ldquo;目录"进一步对动态loader info做了细分.
下面是用<code>jtool</code>输出的格式(类似pagestuff).</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ ./jtool --pages /bin/ls -arch x86_64
0x0-0x8000	__TEXT
	0x3d84-0x73ce	__TEXT.__text
	0x73ce-0x759c	__TEXT.__stubs
	0x759c-0x78ae	__TEXT.__stub_helper
	0x78b0-0x7a93	__TEXT.__const
	0x7a93-0x7f59	__TEXT.__cstring
	0x7f5c-0x7ff8	__TEXT.__unwind_info
0x8000-0xc000	__DATA
	0x8000-0x8008	__DATA.__nl_symbol_ptr
	0x8008-0x8038	__DATA.__got
	0x8038-0x82a0	__DATA.__la_symbol_ptr
	0x82a0-0x84c8	__DATA.__const
	0x84d0-0x84f8	__DATA.__data
0xc000-0xe890	__LINKEDIT
	0xc000-0xc018	Rebase Info     <span style=color:#f92672>(</span>opcodes<span style=color:#f92672>)</span>
	0xc018-0xc080	Binding Info    <span style=color:#f92672>(</span>opcodes<span style=color:#f92672>)</span>
	0xc080-0xc5f0	Lazy Bind Info  <span style=color:#f92672>(</span>opcodes<span style=color:#f92672>)</span>
	0xc5f0-0xc610	Exports
	0xc610-0xc658	Function Starts
	0xc658-0xc680	Data In Code
	0xc680-0xcbd0	Symbol Table
	0xcbd0-0xce54	Indirect Symbol Table
	0xce58-0xd230	String Table
	0xd230-0xe890	Code Signature
</code></pre></div><p>__LINKEDIT的一般布局如下, DYLD大量使用了ULEB128编码(按Jonathan Levin的说法这是一种粗陋的编码方法。), 底层实现者将广泛熟悉该编码，该编码在DWARF和其他二进制相关格式中也有使用.
<img src=https://raw.githubusercontent.com/lyn-euler/assets/master/img/__LINKEDIT.jpg alt=__LINKEDIT></p><h3 id=dyld-opcodes>DYLD Opcodes</h3><p>DYLD使用一种特殊的编码&ndash;由各种<code>opcode</code>组成&ndash;来存储和加载符号绑定信息。这些操作码用于填充LC_DYLD_INFO命令所指向的rebase信息和binding表。有两种类型的操作码。Rebasing操作码和Binding操作码。
Binding操作码（用于lazy和non-lazy符号）被定义为BIND_xxx常数:</p><table><thead><tr><th>opcode</th><th>val</th><th>desc</th></tr></thead><tbody><tr><td>DONE</td><td>0x00</td><td>将当前记录push到导入栈, 并清零记录状态</td></tr><tr><td>SET_DYLIB_ORDINAL_IMM</td><td>0x10</td><td>设置dylib ordinal为immediate(低4-bits). 用于0-15的ordinal number </td></tr><tr><td>SET_DYLIB_ORDINAL_ULEB</td><td>0x20</td><td>以 ULEB128 编码 dylib ordinal 。 用于16+的ordinal number</td></tr><tr><td>SET_DYLIB_SPECIAL_IMM</td><td>0x30</td><td>设置dylib序数，以0或负数为immediate.该值为sign扩展。 目前已知的数值是： BIND_SPECIAL_DYLIB_SELF (0) BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE(-1) BIND_SEPCIAL_DYLIB_FLAT_LOOKUP(-2)</td></tr><tr><td>SET_SYMBOL_TRAILING_FLAGS_IMM</td><td>0x40</td><td>设置符号名（以NULL结尾的char[]） 在immediate值中的标志可以是BIND_SYMBOL_FLAGS_WEAK_IMPORT(0) 或 BIND_SYMBOL_FLAGS_NON_WEAK_DEFINITION(8)</td></tr><tr><td>SET_TYPE_IMM</td><td>0x50</td><td>设置符号类型. TYPE_POINTERTYPE_TEXT_ABSOLUTE32TYPE_TEXT_PCREL32</td></tr><tr><td>SET_ADDEND_SLEG</td><td>0x60</td><td>以SLEB128编码设置addend字段</td></tr><tr><td>SET_SEGMENT_AND_OFFSET_ULEB</td><td>0x70</td><td>将Segment设置为immediate value, 地址以SLEB128编码.</td></tr><tr><td>ADD_ADDR_ULEB</td><td>0x80</td><td>将address字段以SLEB128编码.</td></tr><tr><td>DO_BIND</td><td>0x90</td><td>对当前表行进行绑定</td></tr><tr><td>DO_BIND_ADD_ADDR_ULEB</td><td>0xA0</td><td>进行绑定, 并以ULEB128对地址进行编码</td></tr><tr><td>DO_BIND_ADD_ADDR_IMM_SCALED</td><td>0xB0</td><td>进行绑定, 并以使用scaling添加immediate (lower 4-bits)</td></tr><tr><td>DO_BIND_ADD_ADDR_ULEB _TIMES_SKIPPING_ULEB</td><td>0xC0</td><td>对多个符号进行绑定,并跳过几个字节.罕见</td></tr></tbody></table><p>操作码填充了绑定表中行项的各个列，基本格式是:</p><blockquote><p><code>opcode</code> + [<code>immediate|ULEB128整数|字符数组</code>]</p></blockquote><p>每行以DO_BIND结束。每一行默认携带前一行的值，因此只有在两个符号之间列值发生变化时才会指定一个操作码。这样就可以对表进行压缩。
举个例子🌰:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>0x0000 BIND_OPCODE_SET_DYLIB_ORDINAL_IMM<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span>                                   <span style=color:#75715e># 设置 DYLIB to #3 (第三个LC_LOAD_DYLIB)</span>
0x0001 BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM<span style=color:#f92672>(</span>0x00, __DefaultRuneLocale<span style=color:#f92672>)</span>   <span style=color:#75715e># 设置符号名为 __DefaultRuneLocale</span>
0x0016 BIND_OPCODE_SET_TYPE_IMM<span style=color:#f92672>(</span>1<span style=color:#f92672>)</span>                                            <span style=color:#75715e># 设置类型为 pointer</span>
0x0017 BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB<span style=color:#f92672>(</span>0x02, 0x00000000<span style=color:#f92672>)</span>              <span style=color:#75715e># 设置segement #2 (__DATA)</span>
0x0019 BIND_OPCODE_DO_BIND<span style=color:#f92672>()</span>                                                  <span style=color:#75715e># 第一行结束</span>

<span style=color:#75715e>#</span>
<span style=color:#75715e># 第二行会完全继承第一行的值, 除了覆盖symbol name:</span>
<span style=color:#75715e>#</span>

0x001A BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM<span style=color:#f92672>(</span>0x00, ___stack_chk_guard<span style=color:#f92672>)</span>    <span style=color:#75715e># 设置符号名 __stack_chk_guard</span>
0x002E BIND_OPCODE_DO_BIND<span style=color:#f92672>()</span>

<span style=color:#75715e>#</span>
<span style=color:#75715e># 同样的第三行也只用覆盖符号名:</span>

0x002F BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM<span style=color:#f92672>(</span>0x00, ___stderrp<span style=color:#f92672>)</span>
0x003B BIND_OPCODE_DO_BIND<span style=color:#f92672>()</span>
</code></pre></div><p>这些操作码是由上面提到的<code>dyld_stub_binder</code>使用的，我们后面会讨论。但在此之前，我们必须再做一个转折来解释Mach-O中的两种类型的符号表。</p><h3 id=symbol-tables>Symbol Tables</h3><p>在Mach-O文件中的符号表由LC_SYMTAB命令描述的。链接器是通过 LC_SYMTAB 这个 load command 找到 symbol table, LC_SYMTAB 对应的 command 结构体如下:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> symtab_command {
    uint32_t cmd;     <span style=color:#75715e>/* LC_SYMTAB */</span>
    uint32_t cmdsize; <span style=color:#75715e>/* sizeof(struct symtab_command) */</span>
    uint32_t symoff;  <span style=color:#75715e>/* symbol table offset */</span>
    uint32_t nsyms;   <span style=color:#75715e>/* number of symbol table entries */</span>
    uint32_t stroff;  <span style=color:#75715e>/* string table offset */</span>
    uint32_t strsize; <span style=color:#75715e>/* string table size in bytes */</span>
};
</code></pre></div><p><code>symoff</code>和<code>nsyms</code>指示了符号表的位置和条目，<code>stroff</code>和<code>strsize</code>指示了字符串表的位置和长度.
每个 symbol entry 长度是固定的，其结构由内核定义:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> nlist_64 {
    <span style=color:#66d9ef>union</span> {
        uint32_t  n_strx; <span style=color:#75715e>/* index into the string table */</span>
    } n_un;
    uint8_t n_type;        <span style=color:#75715e>/* type flag, see below */</span>
    uint8_t n_sect;        <span style=color:#75715e>/* section number or NO_SECT */</span>
    uint16_t n_desc;       <span style=color:#75715e>/* see &lt;mach-o/stab.h&gt; */</span>
    uint64_t n_value;      <span style=color:#75715e>/* value of this symbol (or stab offset) */</span>
};
</code></pre></div><ul><li><code>n_un</code>: 符号的名字（在一个 Mach-O 文件里，具有唯一性）</li><li><code>n_sect</code>: 符号所在的 section index（内部符号有效值从 1 开始，最大为 255）</li><li><code>n_value</code>: 符号的地址值（在链接过程中，会随着其 section 发生变化）</li></ul><h3 id=indirect-symbol-table>Indirect Symbol Table</h3><p>indirect symbol table 由LC_DYSYMTAB定义，后者的参数类型是一个dysymtab_command结构体:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> dysymtab_command {
    uint32_t cmd;	<span style=color:#75715e>/* LC_DYSYMTAB */</span>
    uint32_t cmdsize;	<span style=color:#75715e>/* sizeof(struct dysymtab_command) */</span>

    uint32_t ilocalsym;	<span style=color:#75715e>/* index to local symbols */</span>
    uint32_t nlocalsym;	<span style=color:#75715e>/* number of local symbols */</span>

    uint32_t iextdefsym;<span style=color:#75715e>/* index to externally defined symbols */</span>
    uint32_t nextdefsym;<span style=color:#75715e>/* number of externally defined symbols */</span>

    uint32_t iundefsym;	<span style=color:#75715e>/* index to undefined symbols */</span>
    uint32_t nundefsym;	<span style=color:#75715e>/* number of undefined symbols */</span>

    uint32_t tocoff;	<span style=color:#75715e>/* file offset to table of contents */</span>
    uint32_t ntoc;	<span style=color:#75715e>/* number of entries in table of contents */</span>
    uint32_t modtaboff;	<span style=color:#75715e>/* file offset to module table */</span>
    uint32_t nmodtab;	<span style=color:#75715e>/* number of module table entries */</span>

    uint32_t extrefsymoff;	<span style=color:#75715e>/* offset to referenced symbol table */</span>
    uint32_t nextrefsyms;	<span style=color:#75715e>/* number of referenced symbol table entries */</span>

   uint32_t indirectsymoff; <span style=color:#75715e>/* file offset to the indirect symbol table */</span>
    uint32_t nindirectsyms;  <span style=color:#75715e>/* number of indirect symbol table entries */</span>

   
    uint32_t extreloff;	<span style=color:#75715e>/* offset to external relocation entries */</span>
    uint32_t nextrel;	<span style=color:#75715e>/* number of external relocation entries */</span>
    uint32_t locreloff;	<span style=color:#75715e>/* offset to local relocation entries */</span>
    uint32_t nlocrel;	<span style=color:#75715e>/* number of local relocation entries */</span>

};	

</code></pre></div><p>本质上，indirect符号表是 index 数组，即每个条目的内容是一个 index 值，<code>indirectsymoff</code>和<code>nindirectsyms</code>这两个字段定义了 indirect symbol table 的位置信息，每一个条目是一个 4 bytes 的 index 值.</p><h3 id=dyld_stub_binder>dyld_stub_binder</h3><p>至此我们就可以通过indirect符号表找到符号表中的符号了. 但是 lazy binding 最终调用的是<code>dyld_stub_binder</code>, 这个函数具体做了什么呢?</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#e6db74>dyld_stub_binder</span>:
	stp		fp, lr, <span style=color:#f92672>[</span>sp, <span style=color:#75715e>#-16]!</span>
	mov		fp, sp
	sub		sp, sp, <span style=color:#75715e>#240</span>
	stp		x0,x1, <span style=color:#f92672>[</span>fp, <span style=color:#75715e>#-16]	; x0-x7 are int parameter registers</span>
	stp		x2,x3, <span style=color:#f92672>[</span>fp, <span style=color:#75715e>#-32]</span>
	stp		x4,x5, <span style=color:#f92672>[</span>fp, <span style=color:#75715e>#-48]</span>
	stp		x6,x7, <span style=color:#f92672>[</span>fp, <span style=color:#75715e>#-64]</span>
	stp		x8,x9, <span style=color:#f92672>[</span>fp, <span style=color:#75715e>#-80]	; x8 is used for struct returns</span>
	stp		q0,q1, <span style=color:#f92672>[</span>fp, <span style=color:#75715e>#-128]	; q0-q7 are vector/fp parameter registers</span>
	stp		q2,q3, <span style=color:#f92672>[</span>fp, <span style=color:#75715e>#-160]</span>
	stp		q4,q5, <span style=color:#f92672>[</span>fp, <span style=color:#75715e>#-192]</span>
	stp		q6,q7, <span style=color:#f92672>[</span>fp, <span style=color:#75715e>#-224]</span>

	ldr		x0, <span style=color:#f92672>[</span>fp, <span style=color:#75715e>#24]	; move address ImageLoader cache to 1st parameter</span>
	ldr		x1, <span style=color:#f92672>[</span>fp, <span style=color:#75715e>#16]	; move lazy info offset 2nd parameter</span>
	; call dyld<span style=color:#f92672>::</span>fastBindLazySymbol(loadercache, lazyinfo)
	bl		__Z21_dyld_fast_stub_entryPvl
	mov		x16,x0			; save target function address <span style=color:#66d9ef>in</span> lr
	
	; restore parameter registers
	ldp		x0,x1, <span style=color:#f92672>[</span>fp, <span style=color:#75715e>#-16]</span>
	ldp		x2,x3, <span style=color:#f92672>[</span>fp, <span style=color:#75715e>#-32]</span>
	ldp		x4,x5, <span style=color:#f92672>[</span>fp, <span style=color:#75715e>#-48]</span>
	ldp		x6,x7, <span style=color:#f92672>[</span>fp, <span style=color:#75715e>#-64]</span>
	ldp		x8,x9, <span style=color:#f92672>[</span>fp, <span style=color:#75715e>#-80]</span>
	ldp		q0,q1, <span style=color:#f92672>[</span>fp, <span style=color:#75715e>#-128]</span>
	ldp		q2,q3, <span style=color:#f92672>[</span>fp, <span style=color:#75715e>#-160]</span>
	ldp		q4,q5, <span style=color:#f92672>[</span>fp, <span style=color:#75715e>#-192]</span>
	ldp		q6,q7, <span style=color:#f92672>[</span>fp, <span style=color:#75715e>#-224]</span>
	
	mov		sp, fp
	ldp		fp, lr, <span style=color:#f92672>[</span>sp<span style=color:#f92672>]</span>, <span style=color:#75715e>#16</span>
	add		sp, sp, <span style=color:#75715e>#16	; remove meta-parameters</span>
</code></pre></div><p>可以看到最终通过调用dyld::fastBindLazySymbol, 该函数内部通过ImageLoaderMachO::getLazyBindingInfo根据opcode找到符号的真实地址, 并将该地址写入<code>__la_symbol_ptr</code>条目, 最后跳转符号地址.</p><h2 id=总结>总结</h2><p>如图
<img src=https://github.com/lyn-euler/assets/raw/master/img/symbol%20Binding.png alt="symbol Binding"></p><h2 id=参考>参考</h2><ul><li><a href=http://www.m4b.io/reverse/engineering/mach/binaries/2015/03/29/mach-binaries.html>Mach-O Binaries</a></li><li><a href=https://zhangbuhuai.com/post/macho-dynamic-link.html>Mach-O 与动态链接</a></li><li><a href=https://markrepo.github.io/kernel/2018/08/19/dynamic-link/>链接、装载与库 &mdash; 动态链接</a></li><li><a href=http://www.newosxbook.com/articles/DYLD.html>DYLD Detailed</a></li><li>《程序员的自我修养》</li></ul></article><article id=ld64><h2 class=major>ld64</h2><span class="image main"><img src alt></span><p>本文基于ld版本</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>&gt; @<span style=color:#f92672>(</span><span style=color:#75715e>#)PROGRAM:ld  PROJECT:ld64-609</span>
&gt; BUILD 07:59:13 Aug <span style=color:#ae81ff>25</span> <span style=color:#ae81ff>2020</span>
&gt; configured to support archs: armv6 armv7 armv7s arm64 arm64e arm64_32 i386 x86_64 x86_64h armv6m armv7k armv7m armv7em LTO support using: LLVM version 12.0.0, <span style=color:#f92672>(</span>clang-1200.0.32.2<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>static support <span style=color:#66d9ef>for</span> 27, runtime is 27<span style=color:#f92672>)</span> TAPI support using: Apple TAPI version 12.0.0 <span style=color:#f92672>(</span>tapi-1200.0.23<span style=color:#f92672>)</span>
</code></pre></div><h2 id=简介>简介</h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ld files...  <span style=color:#f92672>[</span>options<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>-o outputfile<span style=color:#f92672>]</span>
</code></pre></div><h2 id=描述>描述</h2><p>ld命令将多个对象文件和库结合起来，解析引用，并产生一个输出文件。ld可以产生一个最终的链接镜像(可执行文件、dylib或bundle)，或者使用-r选项，产生一个 另一个object file。 如果不使用-o选项，产生的输出文件被命名为 &ldquo;a.out&rdquo;。</p><h3 id=通用>通用</h3><p>链接器接受通用（多架构）输入文件，但总是创建一个 &ldquo;thin&rdquo;（单架构）的标准Mach-O输出文件。 输出文件的体系结构是通过使用 <code>-arch</code> 选项确定的。 如果不使用这个选项，ld会尝试通过按命令行顺序检查对象文件来确定输出架构。 第一个 &ldquo;thin"架构决定了输出的文件。 如果没有输入对象文件是 &ldquo;thin"文件，则使用主机的原生32位架构。</p><p>通常情况下，不会直接使用ld。 而是由编译器驱动程序调用ld。编译器驱动程序可以传递多个<code>-arch</code>选项，它将通过多次调用ld来创建一个通用的最终链接镜像。然后运行 <code>lipo</code> 将输出合并到一个通用文件中.</p><h3 id=布局>布局</h3><p>object file按照命令行中指定的顺序加载。 segment和这些segment中的section将按照它们在被链接的 object file 中遇到的顺序出现在输出文件中。 所有零填充的section将出现在其segment中所有非零填充的section之后。 用 <code>-sectcreate</code> 选项从文件中创建的section将排在 .o 文件的section之后。使用<code>-order_file</code>选项将改变上面的布局规则，并将指定的符号移动到其部分的开头。</p><h3 id=库>库</h3><p>静态库（又名静态归档）是一个.o文件的集合，它的目录表列出了.o文件中的全局符号，只有在需要解决某些符号引用的时候，ld才会从静态库中提取.o文件。 与传统的链接器不同，ld会在链接的同时不断搜索静态库。不需要在命令行中多次指定静态库。
动态库（又名dylib或框架）是一个最终的链接镜像。 在命令行上放一个动态库会导致两件事。1) 生成的最终链接镜像将有编码表明它依赖于该动态库。2）从动态库导出的符号用于解析引用。
动态库和静态库都是按照它们在命令行中出现的样子进行搜索的</p><h3 id=搜索路径>搜索路径</h3><p>ld维护一个目录列表，用来搜索要使用的库或框架。 默认的库搜索路径是<code>/usr/lib</code>，然后是<code>/usr/local/lib</code>。 ld选项将添加一个新的库搜索路径。 默认的框架搜索路径是<code>/Library/Frameworks</code>，然后是<code>/System/Library/Frameworks</code>。 (注意：以前，<code>/Network/Library/Frameworks</code>是在默认路径的最后面。 如果你需要这个功能，你需要明确添加<code>-F/Network/Library/Frameworks</code>）。) <code>-F</code>选项将添加一个新的框架搜索路径。 <code>-Z</code>选项将删除标准搜索路径。 <code>-syslibroot</code>选项将为所有搜索路径添加一个前缀。</p><h3 id=二级命名空间two-level-namespace>二级命名空间(Two-level namespace)</h3><p>默认情况下，所有解析到动态库的引用都会记录它们被解析到的库。在运行时，dyld 使用这些信息直接解析符号。 另一种方法是使用 <code>-flat_namespace</code> 选项。 使用<code>-flat_namespace</code>则不记录库。 在运行时，dyld 将在解析符号时按加载顺序搜索每个动态库。这虽然速度较慢，但更像其他操作系统解析符号的方式.</p><h3 id=间接动态库>间接动态库</h3><p>如果命令行指定要与 dylib A 链接，而当 dylib A 被构建时，它与 dylib B 链接，那么 B 被认为是间接的 dylib。 当链接到两级命名空间时，ld并不查看间接的dylibs，除非是直接的dylibs再导出。 另一方面，当为扁平命名空间链接时，ld会加载所有间接dylibs，并使用它们来解析引用。 尽管间接dylibs是通过完整路径指定的，ld首先使用指定的搜索路径来定位每个间接dylib。 如果使用搜索路径无法找到，则使用完整路径。</p><h3 id=动态库未定义>动态库未定义</h3><p>当链接到二级命名空间时，ld并不验证dylibs中的undefines是否真的存在。 但是当为扁平命名空间链接时，ld会检查所有加载的dylibs中的undefines是否有一个匹配的定义，有时用于强制从静态库中加载所选函数。</p><h2 id=options>OPTIONS</h2><h3 id=控制输出类型>控制输出类型</h3><ul><li><code>-lx</code>: 这个选项告诉链接器在库搜索路径中搜索 libx.dylib 或 libx.a。 如果字符串x是y.o的形式，那么这个文件会在同样的地方被搜索，但不会在文件名前加上 &ldquo;lib &ldquo;或附加&rdquo;.a &ldquo;或&rdquo;.dylib&rdquo;。</li><li><code>-needed-lx</code>: 这与 <code>-lx</code> 相同，但意思是即使没有使用 dylib 的符号，也要与 dylib 进行真正的链接，因此，它可以用来消除未使用 dylib 的警告。</li><li><code>-reexport-lx</code>: 这与<code>-lx</code>相同，但指定库x中的所有符号应该可以被链接到正在创建的库的clients使用。 这在以前是通过一个单独的<code>-sub_library</code>选项完成的。</li><li><code>-upward-lx</code>: 这与 <code>-lx</code> 相同，但指定 dylib 是向上的依赖关系。</li><li><code>-hidden-lx</code>: 这与定位静态库的<code>-lx</code>相同，但将静态库中的所有全局符号视为可见性隐藏。 用于构建静态库，但不想从该静态库中导出任何东西。</li><li><code>-weak-lx</code>: 这与 <code>-lx</code> 相同，但会强制将库和对它的所有引用标记为弱导入。 也就是说，允许库在运行时缺失。</li><li><code>-needed_library path_to_dylib</code>: 这与将 path_to_dylib 放在链接行上是一样的，区别是即使没有使用 dylib 的符号，也要真正与 dylib 链接。 因此，它可以用来消除未使用的dylib的警告。</li><li><code>-reexport_library path_to_library</code>:指定库路径中的所有符号都应该被链接到正在创建的库的clients所使用. 这在以前是通过一个单独的<code>-sub_library</code>选项来实现的.</li><li><code>-upward_library path_to_library</code>: 将dylib标记为向上的依赖关系</li><li><code>-weak_library path_to_library</code>: 这和在链接行中列出一个库的文件名路径是一样的，只是它强制将库和所有对它的引用标记为弱导入.</li><li><code>-Ldir</code>: 在搜索库的目录列表中添加dir。 用-L指定的目录将按照它们在命令行中出现的顺序，在默认的搜索路径之前进行搜索。在Xcode4及以后的版本，-L和目录之间可以有一个空格。</li><li><code>-Z</code>: 当搜索库和框架时，不要搜索标准目录.</li><li><code>-syslibroot rootdir</code>: 在搜索库或框架时，将rootdir预置到所有搜索路径中。</li><li><code>-search_paths_first</code>: 这现在是默认的（在Xcode4工具中）。 当处理<code>-lx</code>时，链接器现在会在其库搜索路径中搜索每个目录中的 &ldquo;libx.dylib&rdquo;，然后搜索 &ldquo;libx.a&rdquo;，然后再进入库搜索路径的下一个路径.</li><li><code>-search_dylibs_first</code>: 默认情况下，当处理-lx时，链接器会在库搜索路径中的每个目录中搜索 &ldquo;libx.dylib&rdquo;，然后搜索 &ldquo;libx.a&rdquo;。 这个选项改变了行为，首先在库所有搜索路径的每个目录中搜索&rsquo;libx.dylib&rsquo;形式的文件，然后在库搜索路径中搜索&rsquo;libx.a&rsquo;形式的文件。</li><li><code>-framework name[,suffix]</code>: 这个选项告诉链接器搜索&rsquo;name.framework/name&rsquo;的框架搜索路径。 如果指定了可选的后缀，框架将首先搜索带有后缀的名称，然后再搜索不带后缀的(比如先找&rsquo;name.framework/name_suffix'，如果没有的话就找&rsquo;name.framework/name')</li><li><code>-weak_framework name[,suffix]</code>: 这与<code>-framework name[,suffix]</code>相同，但会强制将框架和所有对它的引用标记为弱导入。 注意：由于clang的优化，如果函数没有被标记为weak，如果函数地址为NULL，编译器不做任何检查。</li><li><code>-reexport_framework name[,suffix]</code>: 指定了该框架中的所有符号都应该提供给链接到正在创建的库的clients。 这在以前是用单独的<code>-sub_umbrella</code>选项完成.</li><li><code>-upward_framework name[,suffix]</code>: 指定了该框架是向上的依赖关系.</li><li><code>-Fdir</code>: 在搜索框架的目录列表中添加dir。 用<code>-F</code>指定的目录会按照它们在命令行中出现的顺序，在默认搜索路径之前进行搜索。在Xcode4及以后的版本，在<code>-F</code>和dir之间可以有一个空格.</li><li><code>-all_load</code>: 加载静态归档库的所有成员</li><li><code>-ObjC</code>: 加载实现 Objective-C 类或类别的静态归档库的所有成员</li><li><code>-force_load path_to_archive</code>: 加载指定静态归档库的所有成员。 注意：-all_load 强制加载所有归档库的所有成员。 这个选项允许你针对一个特定的存档.</li><li><code>-load_hidden path_to_archive</code>: 像往常一样使用指定的静态库，但将静态库中的所有全局符号视为可见性隐藏。 当构建一个使用静态库的动态库时很有用。</li></ul><h3 id=其他>其他</h3><ul><li><code>-sectcreate segname sectname file</code>: segname中的sectname是根据file的内容创建的。segname和sectname的组合必须是唯一的，不能和一个来自任何其他输入的段(segname,sectname)的组合重复.</li><li><code>-filelist file[,dirname]</code>: 指定链接器应该链接的文件。 这是在命令行中列出文件的另一种方式。 文件名每行只列出一个，用换行符隔开（空格和制表符被认为是文件名的一部分).如果指定了可选的目录名dirname，则会在列表文件中的每个文件名前加上它。</li><li><code>-dtrace file</code>: 在生成最终链接镜像时启用 dtrace 静态探针。 文件必须是声明静态探针的 DTrace 脚本.</li></ul><h3 id=优化相关选项>优化相关选项</h3><ul><li><p><code>-dead_strip</code>: 删除入口点或导出符号无法到达的函数和数据</p></li><li><p><code>-order_file file</code>: 改变函数和数据的排列顺序。 对于输出文件中的每个section, 该section中在顺序文件中指定的任何符号都会被移到该section的开头.并以与顺序文件中相同的顺序排列. 顺序文件是文本文件，每行有一个符号名。 以#开头的行是注释。 符号名前面可以选择使用它的对象文件叶名和冒号（例如foo.o:_foo）。 这对于在多个文件中出现的静态函数/数据是很有用的。 符号名也可以选择在前面加上架构(例如ppc:_foo或ppc:foo.o:_foo)。 这使得您可以使用一个适用于多种架构的命令文件。 c-字符串可以通过在命令文件中引用字符串来排序(例如 &ldquo;Hello, world\n&rdquo;)。</p></li><li><p><code>-no_order_inits</code>: 当不使用-order_file选项时，链接器会按照对象文件的顺序排列函数，并且会将所有初始化例程移到__text部分的开头，而将终止符例程移到最后。使用该选项可以禁用初始化器和终止器的自动重排。</p></li><li><p><code>-no_order_data</code>: 默认情况下，链接器会对__DATA段中全局数据进行重新排序，这样dyld在启动时需要调整的所有全局变量都会在__DATA段的前部。 这减少了启动时脏页面的数量。 此选项将禁用该优化.</p></li><li><p><code>-platform_version platform min_version sdk_version</code>: 该设置用于指示平台、输出支持该平台上使用的最低的支持版本，以及输出所依据的SDK版本。platform是一个在&lt;mach-o/loader.h>中定义的数值，也可以是以下字符串之一:</p><ul><li>macos</li><li>ios</li><li>tvos</li><li>watchos</li><li>bridgeos</li><li>mac-catalyst</li><li>ios-simulator</li><li>tvos-simulator</li><li>watchos-simulator</li><li>driverkit</li></ul><p>指定一个较新的min或SDK版本，可以使链接器在输出文件中承担该操作系统或SDK的功能。min_version和sdk_version的格式是一个版本号，如10.13或10.14. 相似的还有<code>-macos_version_min version</code>和<code>-ios_version_min</code>选项.</p></li><li><p><code>-image_base address</code>: 指定 dylib 或 bundle 的首选加载地址。参数地址是一个十六进制数字，可选择前导符0x。 通过为程序加载的所有 dylibs 和 bundle 选择非重叠的地址，可以缩短启动时间，因为 dyld 不需要 &ldquo;rebase &ldquo;映像（即调整映像中的指针以在加载的地址工作）。 通常情况下，不使用这个选项更容易，而是使用 rebase(1) 工具，并给它一个 dylibs 列表。 然后，它将为列表选择非重叠的地址，并将它们全部rebase。 这个选项也被称为 -seg1addr，以保证兼容性。</p></li><li><p><code>-no_implicit_dylibs</code>: 在创建两级命名空间最终链接映像时，通常链接器会把隐性链接的公共dylibs吊起来，使两级命名空间编码对dyld来说更有效率。例如，Cocoa重导出AppKit，AppKit重导出Foundation。 如果你用-framework Cocoa链接并使用Foundation的符号，链接器将隐式地添加一个加载命令来加载Foundation，并将该符号编码为来自Foundation。 如果您使用这个选项，链接器将不会为Foundation添加加载命令，并将符号编码为来自Cocoa的符号。 那么在运行时，dyld将不得不在Foundation中搜索Cocoa和AppKit，然后再找到符号。</p></li><li><p><code>-exported_symbols_order file</code>:当以Mac OS X 10.6或更高版本为目标时，可以优化导出的符号信息的格式，使常用符号的查找速度更快。 此选项用于传递一个包含正在构建的动态库的客户端最常使用的符号列表的文件。并非所有导出的符号都需要列出。</p></li><li><p><code>-no_zero_fill_sections</code>: 默认情况下，链接器会将所有零填充部分移动到<code>__DATA</code>段的末尾，并将它们配置为不使用磁盘空间。 这个选项抑制了这种优化，所以在最终的链接映像中，零填充的数据会占据了磁盘上的空间。</p></li><li><p><code>-merge_zero_fill_sections</code>: 将<code>__DATA</code>段的所有零填充部分合并成一个__零填充section.</p></li></ul><h3 id=dylib相关>dylib相关</h3><ul><li><code>-install_name name</code>: 在动态库中设置一个内部的 &ldquo;安装路径&rdquo;(LC_ID_DYLIB)。任何链接到该库的客户端都会将该路径记录为dyld应该定位该库的方式。 如果没有指定这个选项，那么将使用-o路径。 这个选项也被称为<code>-dylib_install_name</code>，以保证兼容性。</li><li><code>-mark_dead_strippable_dylib</code>: 指定正在构建的dylib可以被任何客户端dead strip。 也就是说，dylib没有初始化的副作用。 因此，如果一个客户端链接到dylib，但从未使用任何来自它，链接器可以优化掉dylib的使用。</li><li><code>-compatibility_version number</code>: 指定库的兼容性版本号。 当dyld加载库时，会检查兼容性版本，如果程序的版本大于库的版本，则为错误。 号码格式为X[.Y[.Z]]，其中X必须是小于或等于65535的非零正数，.Y和.Z是可选的，如果存在必须是小于或等于255的非负数。 如果没有指定兼容性版本号，它的值为0，并且在使用库时不进行检查。 这个选项也叫-dylib_compatibility_version，用于兼容性。</li><li><code>-current_version number</code>: 指定库的当前版本号。库的用户可以通过编程获得库的当前版本，这样就可以准确地确定自己使用的是哪个版本的库。 编号的格式为X[.Y[.Z]]，其中X必须是小于或等于65535的非零正数，.Y和.Z是可选的，如果存在必须是小于或等于255的非负数。 如果没有指定版本号，那么它的值为0，这个选项也被称为-dylib_current_version，以保证兼容性。</li></ul><h3 id=可执行文件时的选项>可执行文件时的选项</h3><ul><li><code>-pie</code>: 创建位置无关(PIE)的可执行文件.在Mac OS X 10.5及以后的版本中，操作系统在每次执行时都会在随机地址加载一个PIE。你不能从使用-mdy-namic-no-pic编译的.o文件中创建一个PIE。 这意味着代码生成不那么理想，但地址随机化增加了一些安全性。当以Mac OS X 10.7或更高版本为目标时，PIE是主可执行文件的默认值。</li><li><code>-no_pie</code>: 不使用PIE技术构建可执行文件. 在10.6或更早的版本上默认</li><li><code>-pagezero_size size</code>: 默认情况下，链接器从地址0开始创建一个不可读的段，名为__PAGEZERO。 如果一个NULL指针被取消引用，它的存在将导致一个总线错误。 参数大小是一个十六进制数，前面有一个可选的0x。 如果size为0，链接器将不会生成一个零页段。 在32位架构上，默认情况下，零页大小为4KB。 在64位架构上，默认大小为4GB。</li><li><code>-stack_size size</code>: 指定程序中主线程的最大堆栈大小。 如果没有这个选项，一个程序有8MB的堆栈。 参数大小是一个十六进制数，可选择前导0x。大小应该是架构的页大小（4KB或16KB）的倍数。</li><li><code>-allow_stack_execute</code>: 标记可执行文件，使任务中的所有堆栈都有堆栈执行权限。这包括pthread堆栈。</li><li><code>-export_dynamic</code>: 在LTO期间保留main可执行文件中的所有全局符号。如果没有这个选项，链接时间优化允许内联和删除全局函数。当main可执行文件可能会加载一个需要main可执行文件中某些符号的插件时，就会使用这个选项。</li></ul><h3 id=bundle相关>bundle相关</h3><ul><li><code>-bundle_loader executable</code>:这指定了将executable加载到被链接的 bundle 输出文件中。 从指定的可执行文件中检查来自 bundle 的未定义符号，就像它是与 bundle 链接的动态库一样。</li></ul><h3 id=object-file>Object file</h3><ul><li><code>-keep_private_externs</code>: 不要把私有外部（也就是 visibility=hidden）符号变成静态符号，而是在生成的Object file中把它们作为私有外部。</li><li><code>-d</code>: 强行对常用符号进行定义。 即把暂定的definitions变成real definitions。</li></ul><h3 id=符号解析相关>符号解析相关</h3><ul><li><code>-[un]exported_symbols_list filename</code>: 指定的文件名包含一个全局符号名称的列表，它将作为全局符号留在输出文件中。 所有其它的全局符号将被视为被标记为__private_extern__ (也就是可见性=hidden)，并且在输出文件中不会成为全局符号。file-name 中列出的符号名称必须每行一个。 前导和尾部的空格不属于符号名的一部分。 以#开头的行会被忽略，只有空格的行也会被忽略。 支持一些通配符（类似于shell文件匹配）。 通配符 * 匹配零个或多个字符。 ? 匹配一个字符。 [abc] 匹配一个字符，该字符必须是&rsquo;a'、&lsquo;b&rsquo;或&rsquo;c&rsquo;。 [a-z] 匹配从&rsquo;a&rsquo;到&rsquo;z&rsquo;的任何一个小写字母。<code>-unexported_symbols_list</code>则刚好相反.</li><li><code>-[un]exported_symbol symbol</code>: 指定的符号将被添加到全局符号名称列表中，这些符号将作为全局符号保留在输出文件中。 对于短列表，这比创建一个文件并使用-exported_symbols_list更方便。</li><li><code>-reexported_symbols_list file</code>: 重新导出依赖的dylib中实现的符号名称列表.</li><li><code>-alias symbol_name alternate_symbol_name</code>: 为符号创建一个别名。 默认情况下，别名符号具有全局可见性。 这个选项的前身是-idef:indir选项</li><li><code>-alias_list filename</code>: 指定的文件名包含一个别名列表。符号名和它的别名在一行，用空格隔开。以#开头的行将被忽略。</li><li><code>-flat_namespace</code>: 改变符号在构建时和运行时的解析方式。使用-two_levelnamespace(默认)时，链接器只搜索命令行上的dylibs的符号，并记录它们在哪个dylibs中被找到。 使用-flat_namespace时，链接器会搜索命令行上的所有dylibs以及这些原始dylibs所依赖的所有dylibs。 链接器不会记录外部符号来自哪个 dylib，所以在运行时 dyld 会再次搜索所有的image并使用它找到的第一个定义。 此外，加载的 flat_namespace dylibs 中的任何未定义都必须在构建时进行解析。</li><li><code>-u symbol_name</code>: 指定必须定义符号symbol_name才能成功链接。 这对于强制从静态库中加载选定的函数很有用。</li><li><code>-U symbol_name</code>: 指定 symbol_name 可以没有定义。 使用-two_levelnamespace时，产生的符号将被标记为dynamic_lookup，这意味着dyld将搜索所有加载的image.</li><li><code>-undefined treatment</code>: 指定如何处理未定义的符号，选项有：error, warning, suppress, 或 dynamic_lookup。选项有：error, warning, suppress, 或 dynamic_lookup。 默认为error.</li><li><code>-rpath path</code>: 将路径添加到正在创建的image的runpath搜索路径列表中。 在运行时，dyld会使用runpath来搜索加载路径以@rpath/开头的dylibs。</li><li><code>-commons treatment</code>: 指定如何解决与dylibs相关的共通点（也就是暂定定义）。 选项有：ignore_dylibs, use_dylibs, error。 默认值是ignore_dylibs，这意味着链接器将把object file中的暂定定义变成真正的定义，甚至不检查dylibs的冲突。 dylibs 选项意味着链接器应该检查链接的 dylibs 的定义，并使用它们来替换对象文件中的暂定定义。 错误选项意味着每当对象文件中的暂定定义与链接的dylib中的外部符号发生冲突时，链接器就应该发出一个错误。 也请参见 -warn_commons。</li></ul><h3 id=连接器内省选项>连接器内省选项</h3><ul><li><code>-why_load</code>: 记录静态库中的每个对象文件为什么被加载。也就是需要什么符号。 出于兼容性考虑，也叫-whyload</li><li><code>-why_live symbol_name</code>: 记录对 symbol_name 的一系列引用。 仅适用于 -dead_strip 。 它可以帮助调试为什么你认为应该被删除的dead strip却没有被删除。 关于语法和通配符的使用，请参见 -exported_symbols_list。</li><li><code>-print_statistics</code>: 记录链接器使用的内存量和时间信息.</li><li><code>-t</code>: 记录链接器加载的每一个文件（对象、存档或dylib）。 用于调试搜索路径中加载错误库的问题。</li><li><code>-whatsloaded</code>: 只记录链接器加载的object files.</li><li><code>-order_file_statistics</code>: 记录-order_file的处理信息</li><li><code>-map map_file_path</code>: 将一个map文件写入指定的路径，该文件详细说明了输出image中的所有符号及其地址。</li></ul><h3 id=符号表优化的选项>符号表优化的选项</h3><ul><li><code>-S</code>: 不要将调试信息(STABS或DWARF)放在输出文件中</li><li><code>-x</code>: 不要在输出文件的符号表中放入非全局符号。非全局符号(non-global symbol)在调试和获取回溯轨迹中的符号名时很有用，但在运行时不会使用。如果<code>-x</code>与<code>-r</code>一起使用，非全局符号名就不会被删除，而是用一个唯一的虚名代替，这个虚名将在链接到最终的链接image中时被自动删除。 这使得使用符号来分解代码和数据的dead code striping能够正常工作，并保证了删除源符号名的安全性.</li><li><code>-non_global_symbols_strip_list filename</code>: 指定的文件名包含一个非全局符号名的列表，这些符号名应该从输出文件的符号表中删除。 所有其他的非全局符号名将保留在输出文件的符号表中。关于语法和通配符的使用，请参见-exported_symbols_list。</li><li><code>-non_global_symbols_no_strip_list filename</code>: 指定的文件名包含一个非全局性的符号名列表，这些符号名应该保留在输出文件的符号表中。 所有其他的符号名将从输出文件的符号表中删除。关于语法和通配符的使用，请参见-exported_symbols_list。</li><li><code>-oso_prefix prefix-path</code>: 当生成调试图时，链接器将从OSO符号的路径中删除指定的前缀-路径。这可以用来帮助构建服务器生成相同的二进制文件</li></ul><h3 id=bitcode-构建相关>Bitcode 构建相关</h3><ul><li><code>-bitcode_bundle</code>: 在输出二进制文件中生成一个嵌入的bitcode bundle。bitcode bundle嵌入在section(__LLVM，__bundle)部分。 这个选项要求所有的对象文件、静态库和用户框架/dylibs都包含bitcode。 注意：并不是所有的链接器选项都支持和-bitcode_bundle一起使用。</li><li><code>-bitcode_hide_symbols</code>: 与-bitcode_bundle一起指定这个选项，可以从输出的bitcode bundle中隐藏所有未导出的符号。 隐藏符号的过程可能是不可逆的。要获得一个反向映射文件来恢复所有的符号，使用-bitcode_symbol_map选项</li><li><code>-bitcode_symbol_map path</code>: 输出bitcode符号反向映射文件（.bcsymbolmap）。如果路径是一个现有的目录，UUID.bcsymbolmap将被写入该目录。 否则，反转映射将被写入path指定的文件.</li></ul><h3 id=比较少用的选项>比较少用的选项</h3><ul><li><code>@response_file_path</code>: 将response_file_path处的文件内容插入到参数中。这允许linker命令行参数存储在一个文件中。 注意: ld通常是通过clang调用的，clang也会在命令行解释@file。 要想让 clang 忽略 @file 并将其传递给 ld，使用 <code>-Wl,@file</code>.</li><li><code>-v</code>: 打印linker版本</li><li><code>-version_detail</code>: 以JSON格式打印链接器的版本信息.</li><li><code>-no_weak_imports</code>: 如果任何符号是weak import的（即允许在运行时未解析（NULL）），则出现错误。对基于配置的项目很有用，因为这些项目假设是在同一个操作系统版本上构建和运行的。</li><li><code>-no_deduplicate</code>: 不要在链接器中运行重复数据删除pass</li><li><code>-verbose_deduplicate</code>: 打印通过删除重复数据(deduplication)去掉的函数名称和节省的总代码量.</li><li><code>-no_inits</code>: 如果输出包含任何静态initializers, 则出错</li><li><code>-no_warn_inits</code>: 如果输出包含任何静态initializers, 也不报警告</li><li><code>-debug_variant</code>: 忽略二进制输送给customer的错误警告</li><li><code>-unaligned_pointers treatment</code>: 指定如何处理__DATA段中未对齐的指针.选项有：&lsquo;warning&rsquo;、&lsquo;error&rsquo;或&rsquo;suppress&rsquo;。&lsquo;warning&rsquo;, &lsquo;error&rsquo;, 或 &lsquo;suppress&rsquo;. arm64e的默认值是&rsquo;error'，而所有其他架构的默认值是&rsquo;suppress'</li><li><code>-dirty_data_list filename</code>: 指定一个包含可能被污染的数据符号名称的文件。 如果链接器有创建一个__DATA_DIRTY段，那么这些符号将被移到该段中.</li><li><code>-max_default_common_align value</code>: 任何没有显式对齐的普通符号（也就是暂定的，或者未初始化（归零）的变量）通常都会被对齐到它们的下一个2的幂数大小（例如，一个240字节的数组是256个对齐）. 这个选项可以让你减少最大对齐度。 例如，值为0x40将减少240字节数组的对齐方式为64字节（而不是256）。如果不使用 -max_default_common_align，对于 -preload，默认对齐方式已经被限制为 0x8 (2^3) 字节，对于所有其他输出类型，默认对齐方式为 0x8000 (2^15)。</li><li><code>-move_to_rw_segment segment_name filename</code>: 将数据符号移动到另一个段。 命令行选项指定目标段名称和包含要移动的符号列表的文件路径。 可以通过以#开头的行向符号文件添加注释。 如果一个符号名有多个实例（例如在多个文件中的 &ldquo;static int foo=5;"），符号列表文件中的符号名可以用对象文件名作为前缀（例如 &ldquo;init.o:_foo&rdquo;）来移动一个特定的实例。</li><li><code>-move_to_ro_segment segment_name filename</code>: 同上, 不过该选项针对只读目标段.</li><li><code>-rename_section orgSegment orgSection newSegment newSection</code>: 重命名section名称</li><li><code>-rename_segment orgSegment newSegment</code>: 重命名segment名称</li><li><code>-trace_symbol_layout</code>: 用于调试 <code>-rename_section</code>, <code>-rename_segment</code>, <code>-move_to_ro_segment</code>, 和 <code>-move_to_rw_segment</code>。 这个选项可以打印出一行显示每个符号被移动的位置和原因。 注意：这些选项是连锁的。 对于每个符号，链接器首先检查<code>-move_to_ro_segment</code>和<code>-move_to_rw_segment</code>。接下来应用任何<code>-rename_section</code>选项，最后应用<code>-rename_segment</code>选项。</li><li><code>-section_order segname colon_separated_section_list</code>: 仅与 <code>-preload</code> 一起使用。 指定指定segment中section的排列顺序. 如: <code>-section_order __ROM __text:__const:__cstring</code>.</li><li><code>-segment_order colon_separated_segment_list</code>: 仅与-preload一起使用。 指定segment的排列顺序。 例如 <code>-segment_order __ROM:__ROM2:__RAM</code></li><li><code>-allow_heap_execute</code>: 通常 i386 主可执行文件会被标记为只允许 Mac OS X 10.7 及更高版本的内核执行特定 x-bit 页的指令。这个选项覆盖了这一行为，允许执行任何页上的指令</li><li><code>-application_extension</code>: 指定代码被链接到应用程序扩展中使用。 链接器将验证任何被链接的动态库是否可以安全地用于应用扩展</li><li><code>-no_application_extension</code>: 指定被链接的代码在应用扩展中使用不安全。 例如，可以在创建一个不应该在应用程序扩展中使用的框架时使用.</li><li><code>-fatal_warnings</code>: 如果产生任何警告，会导致链接器以一个非零值退出</li><li><code>-no_eh_labels</code>: 通常在<code>-r</code>模式下，链接器会在<code>__eh_frame</code>section的所有FDE上产生<code>.eh</code>标签。 这个选项会抑制这些标签。 Mac OS X 10.6后链接器不需要这些标签，但早期的链接器工具需要这些标签。</li><li><code>-warn_compact_unwind</code>: 当生成最终的链接镜像时，链接器会处理<code>__eh_frame section</code>，并产生一个<code>__unwind_info section</code>.在 <code>__eh_frame</code> 中的大多数 FDE 条目可以用 <code>__unwind_info</code> 部分的一个 32 位值来表示。 该选项会对任何FDE不能用紧凑的unwind格式(compact unwind format)表示的函数发出警告.</li><li><code>-warn_weak_exports</code>: 如果最终链接的image包含弱外部符号(weak external symbol), 则发出警告.需要dyld在启动时做额外的工作来凝聚(coalesce)这些符号.</li><li><code>-no_weak_exports</code>: 如果最终链接的image包含弱外部符号(weak external symbol), 则报错.</li><li><code>-objc_gc_compaction</code>: 在最终链接的镜像中标记Objective-C镜像信息，并注明代码是为了压缩垃圾收集而构建的位。</li><li><code>-objc_gc</code>: 验证所有代码是否是由 <code>-fobjc-gc</code> 或 <code>-fobjc-gc-only</code> 编译所得.</li><li><code>-objc_gc_only</code>: 验证所有代码是否是由 <code>-fobjc-gc-only</code> 编译所得.</li><li><code>-warn_unused_dylibs</code>: 对没有使用任何符号链接的dylibs给出警告信息.</li><li><code>-no_warn_unused_dylibs</code>: 没有使用任何符号链接的dylibs也不给警告信息.</li><li><code>-dead_strip_dylibs</code>: 删除入口点或导出符号无法到达的dylibs。也就是抑制在链接过程中没有提供符号的dylibs生成加载命令指令。当链接到一个由于某种间接原因而在运行时需要的dylib时，如该dylib有一个重要的初始化器时，不应使用该选项。</li><li><code>-allow_sub_type_mismatches</code>: 通常链接器认为ARM的不同cpu-subtype(例如armv4t和armv6)是不同的架构，在构建时不能混合。 这个选项放宽了这个要求，允许你混合为不同的ARM子类型编译的object file.</li><li><code>-no_uuid</code>: 不要在输出文件中生成LC_UUID加载命令。 请注意，没有UUID的二进制文件可能导致调试器和崩溃报告工具无法跟踪和检查二进制文件。</li><li><code>-random_uuid</code>: 在输出文件中随机生成一个LC_UUID加载命令。默认情况下，链接器会根据输出文件内容的哈希值来生成输出文件的UUID。但是对于非常大的输出文件，哈希会减慢链接的速度。使用基于哈希值的UUID对于可重现的构建是很重要的，但如果你只是在做快速调试构建，使用-random_uuid可能会改善周转时间.</li><li><code>-root_safe</code>: 设置输出文件mach头中的MH_ROOT_SAFE位.</li><li><code>-setuid_safe</code>: 设置输出文件mach头中的 MH_SETUID_SAFE 位.</li><li><code>-interposable</code>: 创建动态库时，可间接访问所有导出的符号.</li><li><code>-init symbol_name</code>: 指定的 symbol_name 将作为第一个初始化器运行。 仅在创建动态库时使用.</li><li><code>-sub_library library_name</code>: 导出指定动态库. 比如<code>/usr/lib/libobjc_profile.A.dylib</code>的library_name为libobjc. 仅在创建动态库时使用.</li><li><code>-sub_umbrella framework_name</code>: 导出指定framework仅在创建动态库时使用.</li><li><code>-allowable_client name</code>: 限制哪些client可以链接到正在创建的动态库。 默认情况下，任何代码都可以链接到任何 dylib。但是如果一个 dylib 被认为是一小部分client的私有库，你可以用<code>-allowable_client</code>限定每个可以使用该动态库的client。 如果一个client是 libfoo.1.dylib，它的 <code>-allowable_client</code> 名称将是 &ldquo;foo&rdquo;。 如果客户端是Foo.framework，它的<code>-allowable_client</code>名称将是 &ldquo;Foo&rdquo;。 对于你不想让任何人链接到一个dylib的情况，你可以将<code>-allowable_client</code>设置为&rdquo;！"。</li><li><code>-client_name name</code>: 启用一个bundle去链接一个通过<code>-allowable_client</code>创建的dylib. name 必须是创建dylib时<code>-allowable_client</code>指定中的一个.</li><li><code>-umbrella framework_name</code>: 指定动态库通过指定的umbrella framework重新导出.</li><li><code>-headerpad size</code>: 指定将来扩展加载命令的最小空间. 只有在后面运行 install_name_tool 来修改加载命令时才有用. 大小是一个十六进制数</li><li><code>-headerpad_max_install_names</code>: 自动为将来的加载命令添加空间，使所有路径都能扩展到MAXPATHLEN。 只有当你打算运行 install_name_tool 来改变加载命令时才有用.</li><li><code>-bind_at_load</code>: 在生成的二进制文件的mach头中设置一个位，告诉dyld在加载二进制文件时绑定所有符号，而不是懒绑定.</li><li><code>-force_flat_namespace</code>: 在生成的二进制文件的mach头中设置一个位，它告诉dyld不仅要为二进制文件使用flat namespace，而且要强制在进程中加载的所有dylibs和bundles上绑定flat namespace。 只能在链接主可执行文件时使用。</li><li><code>-sectalign segname sectname value</code>: 将其对齐方式设置为value，其中value是一个十六进制数，必须是2的整数倍.</li><li><code>-stack_addr address</code>: 指定栈指针值的初始地址，其中value是一个十六进制数，四舍五入到页边界.</li><li><code>-segprot segname max_prot init_prot</code>: 指定segname的segemnt的最大和初始化内存保护, max_prot和init_prot的值是 &ldquo;r&rdquo;(读)、&ldquo;w&rdquo;(写)、&ldquo;x&rdquo;(执行)和&rdquo;-"(无访问)等字符的任意组合.</li><li><code>-seg_addr_table filename</code>: 指定一个包含动态库基址的文件。 文件的每一行都是一个十六进制的基地址，后面是空格，然后是相应dylib的安装名称。#字符表示注释.</li><li><code>-seg_addr_table filename</code>: 指定一个包含动态库基址的文件。 文件的每一行都是一个十六进制的基地址，后面是空格，然后是相应dylib的安装名称。#字符表示注释。</li><li><code>-segs_read_write_addr address</code>: 允许构建只读和读写段不连续的动态库。 指定的地址是一个十六进制数，表示读写段的基本地址。</li><li><code>-segs_read_only_addr address</code>: 允许构建只读和读写段不连续的动态库。 指定的地址是一个十六进制数，表示只读段的基本地址。</li><li><code>-segaddr name address</code>: 指定命名为name的段的起始地址。地址必须是一个十六进制数，是 4K 页大小的倍数.</li><li><code>-seg_page_size name size</code>: 指定segment使用的page size.默认情况下，所有segment页面大小为4096。 链接器布局segment的大小总是其页面大小的偶数倍.</li><li><code>-dylib_file install_name:file_name</code>: 指定动态共享库的位置与标准位置不同。install_name 指定了库通常所在的路径，file_name 指定了你想使用的库的路径，例如，如果你链接到一个依赖动态库libsys的库，而你的libsys安装在非默认位置，那么使用这个选项。 例如，如果您链接到一个依赖于动态库 libsys 的库，并且您将 libsys 安装在一个非默认位置，您可以使用这个选项： <code>-dylib_file /lib/lib-sys_s.A.dylib:/me/lib/libsys_s.A.dylib</code>。</li><li><code>-prebind</code>: 所创建的输出文件将是预绑定格式。 在Mac OS X 10.3和更早的版本中使用的，以提高启动性能。</li><li><code>-weak_reference_mismatches treatment</code>: 指定如果一个符号在一个object file中被弱导入，但在另一个对象文件中没有被弱导入，该如何处理。 有效的处理方法是：错误、弱或非弱导入。 默认值是non-weak。</li><li><code>-read_only_relocs treatment</code>: 允许使用重定位，这将导致dyld修改（写后复制）只读页面。 编译器通常不会产生这样的代码.</li><li><code>-force_cpusubtype_ALL</code>: 只适用于 -arch ppc。 它告诉链接器忽略object file中编码的PowerPC cpu要求(如G3, G4或G5)，并将生成的二进制文件标记为可在任何PowerPC cpu上运行。</li><li><code>-dylinker_install_name path</code>: 只用于构建dyld</li><li><code>-no_arch_warnings</code>: 忽略关于<code>-arch</code>标志有错误架构的文件的警告信息.</li><li><code>-arch_errors_fatal</code>: 将-arch标志有错误架构的文件的警告转化为错误</li><li><code>-e symbol_name</code>: 指定一个主可执行文件的入口点。 默认情况下，入口名称是 &ldquo;start&rdquo;，它在crt1.o中找到，其中包含了设置和调用main()所需的glue代码</li><li><code>-w</code>: 忽略所有警告信息</li><li><code>-final_output name</code>: 如果没有使用·-install_name·，则指定dylib的安装名称。 当编译器驱动程序调用<code>-arch</code>指定多个参数时，会使用这个选项。</li><li><code>-arch_multiple</code>: 指定链接器应该用架构名来增加错误和警告信息。 这个选项在编译器驱动程序调用多个-arch参数时使用。</li><li><code>-twolevel_namespace_hints</code>: 在生成的二进制文件中添加提示，只要被链接的库没有改变，这些提示就可以帮助加速dyld的运行时绑定。</li><li><code>-dot path</code>: 在指定的路径上创建一个包含符号依赖关系图的文件。 可以在 GraphViz 中查看 .dot 文件.</li><li><code>-keep_relocs</code>: 在最终的链接映像中添加基于section的重定位记录。 这些重定位记录在运行时被 dyld 忽略。</li><li><code>-warn_stabs</code>: 当由于编译器在BINCL/EINCL范围内置了一个bad stab符号而导致链接器不能进行BINCL/EINCL优化时，打印一个警告。</li><li><code>-warn_commons</code>: 每当发现object file中的tentative definition和链接的 dylib 中也有同名的外部符号时，都会打印一个警告。 这通常意味着头文件中的变量声明中缺少extern关键字。</li><li><code>-read_only_stubs</code>: [仅限 i386] 使最后链接image的 <code>__IMPORT</code> 段只读。 这个选项使程序稍微安全一些，因为 i386 <code>fast stub</code>中的 JMP 指令不会轻易被恶意代码覆盖。 缺点是 dyld 必须使用 mprotect() 在绑定存根时暂时使该段可写。</li><li><code>-slow_stubs</code>: [仅适用于i386]链接器不使用单个JMP指令stub，而是在__TEXT段创建代码，通过__DATA段的懒惰指针进行调用。</li><li><code>-interposable_list filename</code>: 指定的filename包含一个全局符号名的列表，这些符号名总是应该被间接访问。 例如，如果libSystem.dylib的链接使得_malloc是可互换的，那么对_malloc的调用就应该是间接的。 malloc()会经过dyld stub，并有可能间接到另一个 malloc。 如果libSystem.dylib在构建时没有将_malloc作为可替换的对象，那么如果_malloc在运行时被插入，来自libSystem的malloc的调用会被忽略（没有被插入），因为它们是直接调用。</li><li><code>-no_function_starts</code>: 默认情况下，链接器会在最终链接image的LINKEDIT中创建一个函数起始地址的压缩表。 这个选项可以禁止这种行为.</li><li><code>-no_objc_category_merging</code>: 默认情况下，当链接生成最终的镜像时，链接器会通过将类的所有category合并到类中来优化Objective-C类。 类和它的类别都必须被定义在镜像，以便进行优化。 使用此选项将禁用该行为。</li><li><code>-objc_relative_method_list</code>: 默认情况下，当制作最终的链接镜像时，如果目标是一个足够新的OS版本，链接器将重写ObjC方法列表，从传统的三个指针到使用三个只读的delta指针. 这个选项允许你强制使用相对方法列表，即便OS版本太低。</li><li><code>-no_objc_relative_method_lists</code>:默认情况下，当制作最终的链接镜像时，如果目标是一个足够新的操作系统版本，链接器将重写ObjC方法列表，从传统的三个指针到使用三个只读的delta指针。这个选项允许你强制使用传统的三个指针方法列表。</li><li><code>-object_path_lto filename</code>: 当执行链接时间优化（LTO）时，需要一个临时的mach-o对象文件，如果使用这个选项，临时文件将存储在指定的路径上，并在链接完成后保留。 如果没有这个选项，链接器会在链接工具完成之前选取一个路径并删除对象文件，因此调试器或dsymutil等工具将无法访问临时对象文件中的DWARF调试信息.</li><li><code>-lto_library path</code>: 当执行链接时间优化（LTO）时，链接器通常会相对于链接器二进制文件（&mldr;/lib/libLTO.dylib）加载libLTO.dylib。这个选项允许用户指定一个特定的libLTO.dylib的路径来代替</li><li><code>-cache_path_lto path</code>: 当执行增量链接时间优化（LTO）时，使用此目录作为增量重建的缓存</li><li><code>-prune_interval_lto seconds</code>: 当执行增量链路时间优化（LTO）时，缓存将在指定的时间间隔后进行修剪(pruned)。值为0将强制修剪，值为-1将禁止修剪</li><li><code>-prune_after_lto seconds</code>: 当为增量链路时间优化(LTO)修剪缓存时，缓存条目会在指定的时间间隔后被删除。</li><li><code>-max_relative_cache_size_lto percent</code>: 当执行增量链接时间优化(LTO)时，缓存将被修剪成不超过可用空间的这个百分比。即100的值表示缓存可能会填满磁盘，50的值表示缓存的大小将被保持在可用磁盘空间以下.</li><li><code>-fixup_chains_section</code>: 当使用<code>-pie</code>时，与<code>-static</code>或<code>-preload</code>一起使用。 告诉链接器添加一个<code>__TEXT,__chain_starts</code> 部分，该部分以 <code>dyld_chained_starts_offsets</code> 结构开始，该结构指定了指针格式和每个fixup链开始的偏移量</li><li><code>-threaded_starts_section</code>: 仅适用于arm64e, 当使用<code>-pie</code>时，与<code>-static</code>或<code>-preload</code>一起使用。告诉链接器增加一个__TEXT,__thread_starts的部分，该部分以一个32位标志字段开始，后面是一个32位的数组。 每个值都是固定链开始的偏移量。这个选项已经过时了。</li><li><code>-page_align_data_atoms</code>: 在开发过程中，这个选项可以用来给所有的全局变量留出空间，使每个变量都在一个单独的页上。 这在分析脏页和常驻页时很有用。 这些信息可以用来创建一个顺序文件，将常用的/肮的全局变量集中到同一个页面上。</li><li><code>-not_for_dyld_shared_cache</code>: 通常情况下，链接器会给以 <code>-install_name</code> 开头的 dylibs 添加额外的信息，这些信息以 <code>/usr/lib</code> 或 <code>/System/Library/</code> 开头，允许 dylib 被放入 dyld 共享缓存中。 添加这个选项让链接器不添加额外的信息。</li></ul><h3 id=过时选项>过时选项</h3><ul><li><code>-segalign value</code>:</li><li><code>-seglinkedit</code>:</li><li><code>-noseglinkedit</code>:</li><li><code>-fvmlib</code>:</li><li><code>-sectobjectsymbols segname sectname</code>:</li><li><code>-nofixprebinding</code>:</li><li><code>-noprebind_all_twolevel_modules</code>:</li><li><code>-prebind_all_twolevel_modules</code>:</li><li><code>-prebind_allow_overlap</code>:</li><li><code>-noprebind</code>:</li><li><code>-sect_diff_relocs treatment</code>:</li><li><code>-run_init_lazily</code>:</li><li><code>-single_module</code>:</li><li><code>-multi_module</code>:</li><li><code>-no_dead_strip_inits_and_terms</code>:</li><li><code>-A basefile</code>:</li><li><code>-b</code>:</li><li><code>-Sn</code>:</li><li><code>-Si</code>:</li><li><code>-Sp</code>:</li><li><code>-X</code>:</li><li><code>-s</code>:</li><li><code>-m</code>:</li><li><code>-ysymbol</code>:</li><li><code>-Y number</code>:</li><li><code>-nomultidefs</code>:</li><li><code>-multiply_defined_unused treatment</code>:</li><li><code>-multiply_defined treatment</code>:</li><li><code>-private_bundle</code>:</li><li><code>-noall_load</code>:</li><li><code>-seg_addr_table_filename path</code>:</li><li><code>-sectorder</code>:</li><li><code>-sectorder_detail</code>:</li><li><code>-lazy_framework name[,suffix]</code>:</li><li><code>-lazy-lx</code>:</li><li><code>-lazy_library path_to_library</code>:</li></ul></article><article id=v1deqziwlu9dihj1bnrpbwxmllnov5s><h2 class=major>WWDC20-OC runtime改进</h2><span class="image main"><img src alt></span><h2 id=类结构体变化>类结构体变化</h2><p>在你的应用程序的磁盘上，二进制类是这样的.
<img src=./15933251515193/%E6%88%AA%E5%B1%8F2020-06-28%2018.11.38.png alt="截屏2020-06-28 18.11.38"></p><p>首先是类对象本身，它包含了最常被访问的信息：指向元类、超类和方法缓存的指针.它还有一个指向更多数据的指针.存储额外信息的地方叫做 <code>class_ro_t</code>.RO代表只读，该结构体包括像类名，方法、协议和实例变量的信息.
<img src=./15933251515193/15933391421728.png alt></p><p>Swift类和Objective-C类共享这个基础架构，所以每个Swift类也有这些数据结构.当类第一次从磁盘加载到内存中时，它们一开始也是这样的.但是一旦使用了它们，它们就会发生变化.
在阐述具体发生什么之前先了解两个概念:</p><ul><li><p><strong>Clean Memory</strong>: 是指一旦加载后就不会改变的内存
比如<code>class_ro_t</code>就是clean的, 因为它是只读的.</p></li><li><p><strong>Dirty Memory</strong>: 脏内存是指在进程运行时被改变的内存
类结构一旦被使用，就会被弄脏，因为运行时会向它写入新的数据(例如它创建了一个新的方法缓存，并从类中指向它).
Dirty Memory 要比 Clean Memory 昂贵的多, 因为只有进程在运行，它就必须一直存在; 而Clean Memory是不变的, 如果需要系统能从磁盘中重新加载它, 所以可以从内存中移除.
MacOS 中有swap脏内存的可选操作, 但是因为iOS没有使用swap,脏内存在iOS中的代价会特别大.出于这个原因,能保持干净的数据越多越好, 原来的类结构体被划分为两块.通过分离出那些永远不会改变的数据，那就可以把大部分的类数据作为干净的内存来保存.
这些数据足以让我们开始使用，但运行时需要跟踪每个类的更多信息, 所以，当一个类第一次被使用时，运行时会为它分配额外的存储空间. 这个运行时分配的存储是可读可写的数据<code>class_rw_t</code>.在这个数据结构中，我们存储了只有在运行时产生的新信息.例如，所有的类都会使用这些First Subclass和Next Sibling Class指针链接成一个树形结构.
<img src=./15933251515193/%E6%88%AA%E5%B1%8F2020-06-28%2018.15.03.png alt="截屏2020-06-28 18.15.03">
而且这允许运行时遍历当前使用的所有类，这对于无效的方法缓存很有用.但是，既然方法和属性也在只读数据中，为什么我们要在这里有方法和属性呢？嗯，因为它们可以在运行时改变.当一个Category被加载时，它可以向类中添加新的方法.而且程序员可以使用运行时API动态添加它们.由于class_ro_t是只读的，所以我们需要在<code>class_rw_t</code>中跟踪这些东西.
<img src=./15933251515193/%E6%88%AA%E5%B1%8F2020-06-28%2018.15.32.png alt="截屏2020-06-28 18.15.32"></p><p>现在发现，这样做会占用不少的内存.在任何一个给定的设备中，都有很多类在使用.我们在一台iPhone上测得整个系统中大约有30MB的这些<code>class_rw_t</code>结构.
那么我们如何才能缩小这些呢？请记住，我们在读/写部分都需要这部分数据，因为它们可以在运行时改变.但是&mldr;&mldr;检查实际设备上的使用情况，苹果发现只有10%左右的类真正改变过它们的方法.而且这个Demangled Name字段只有Swift类才会使用，除非有东西询问他们的Objective-C名称，否则Swift类也根本不需要它.所以，我们可以把那些平时不用的部分拆掉.
<img src=./15933251515193/%E6%88%AA%E5%B1%8F2020-06-28%2018.18.28.png alt="截屏2020-06-28 18.18.28">
<img src=./15933251515193/15933395479251.png alt></p><p>这样一来，class_rw_t的大小就减少了一半.对于那些确实需要额外信息的类，我们可以分配一个这样的扩展记录，然后把它滑到类中供其使用.大约90%的类从来不需要这些扩展数据，整个系统节省了大约14MB.这些内存现在可以用于更有成效的用途，比如存储你的应用程序的数据.
因此，你可以通过在终端中运行一些简单的命令，亲自在 Mac 上看到这一变化的影响.</p></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#75715e># note:确认对应的App在运行</span>
heap Mail | egrep <span style=color:#e6db74>&#39;class_rw|COUNT&#39;</span>
</code></pre></div><p><img src=./15933251515193/15933396611691.png alt></p><p>而从返回的结果中，我们可以看到，我们在邮件应用中使用了大约9000个这样的class_rw_t类型，但实际上其中只有大约十分之一，900多一点，需要使用这个扩展信息. 单邮件这一个应用我们就节省了大约25万兆的数据. 如果我们在系统范围内进行扩展，那就真正能节省了很多脏内存带来的开销.
修改之后很多从类中获取数据的代码必须同时处理那些有和没有扩展数据的类.当然，因为读取和更新这些结构的代码都在runtime内, runtime内部会为你处理所有这些操作，从外部看一切都像以前一样，只是使用更少的内存.
所以尽量使用runtime提供的API，因为这部分数据结构的更改, 任何第三方试图直接访问这些数据结构的代码在今年的操作系统版本中都会停止工作.</p><h2 id=方法列表变化>方法列表变化</h2><p>接下来，让我们再深入了解一下这些类的数据结构，看看另一个变化：相对方法列表(relative method lists).每个类都有一个附加的方法列表.当你在一个类上写一个新方法时，它就会被添加到列表中.runtime使用这些列表来解析消息发送.
<img src=./15933251515193/%E6%88%AA%E5%B1%8F2020-06-28%2018.23.32.png alt="截屏2020-06-28 18.23.32"></p><p>每个方法都包含三条信息:
首先是方法的名称，或者说<code>Selector</code>;<code>Selector</code>是字符串，但它们是唯一的，所以它们可以使用指针平等来比较.
其次是方法的类型编码(type encoding).这是一个表示参数和返回类型的字符串，它不是用来发送消息的，但它是运行时反省(introspection)和消息转发(forwarding)等必需的.
最后，还有一个指向方法的实现的指针&ndash;方法的实际代码.当你写一个方法时，它会被编译成一个C函数，里面有你的实现，然后条目(entry)和方法列表都指向这个函数.让我们看看一个具体的方法.
<img src=./15933251515193/15933399137465.png alt></p><p>我选择了<code>init</code>方法.它包含了方法名、类型和实现.方法列表中的每一条数据都是一个指针.
在我们的64位系统中，这意味着每个方法表条目占用24个字节.现在这是干净的内存，但干净的内存并不是免费的.它仍然必须从磁盘加载，并且在使用时占用内存.现在这里是一个进程内内存的放大视图(NOTE:这不是按比例放大的).
<img src=./15933251515193/15933399608276.png alt></p><p>有一个很大的地址空间，需要64位来寻址.在这个地址空间内，为栈、堆以及加载到进程中的可执行文件和库或二进制映像划分出了不同的部分，这里用蓝色显示.让我们放大来看其中的一个二进制镜像.
<img src=./15933251515193/%E6%88%AA%E5%B1%8F2020-06-28%2018.26.51.png alt="截屏2020-06-28 18.26.51">
这里我们显示了三个方法表项指向其二进制中的位置.这向我们展示了另一个成本.二进制图像可以加载到内存中的任何地方，这取决于动态链接器决定把它放在哪里.这意味着链接器需要在加载时将指针解析到镜像中，并将其fix up为指向其在内存中的实际位置.而这也是有代价的.
现在，请注意，一个来自二进制的类方法条目永远只指向该二进制内的方法实现.没有办法让一个方法的元数据在一个二进制中，而实现它的代码在另一个二进制中.这意味着方法列表条目实际上不需要能够引用整个64位地址空间.它们只需要能够引用自己二进制中的函数，而且这些函数总是在附近.因此，他们可以在二进制中使用一个32位的相对偏移，而不是一个绝对的64位地址.
这也是苹果今年做的一个改变.</p><p><img src=./15933251515193/%E6%88%AA%E5%B1%8F2020-06-28%2018.28.01.png alt="截屏2020-06-28 18.28.01"></p><p>这有几个好处.首先，无论image在哪里加载到内存中，偏移量始终是相同的，所以它们不必在从磁盘加载后进行修正. 而且因为它们不需要被修正起来, 它们可以被保存在真正的只读内存中，这样更安全.当然，32位的偏移意味着我们已经将64位平台上所需的内存量减少了一半.
<img src=./15933251515193/%E6%88%AA%E5%B1%8F2020-06-28%2018.28.53.png alt="截屏2020-06-28 18.28.53"></p><p>苹果工程师在一个典型的iPhone上测得关于BOMB的这些方法的系统范围, 节省了40MB.</p><p><strong>但是swizzling呢</strong>？二进制中的方法列表现在不能引用整个地址空间.但是，如果你swizzle一个可以在任何地方实现的方法，而且，我们刚刚说过，我们希望保持这些方法列表只读.为了处理这个问题，苹果也提供了一个全局表，将方法映射到它们被swizzle的实现上.Swizzling是很少见的.绝大多数方法实际上从未被swizzle过，所以这个表最终不会变得很大.更好的是这个表很紧凑.
我们知道内存是按页分配的, 在旧的方法列表实现中, swizzle一个方法会弄脏它所在的整个页面，导致swizzle一次就会弄脏很多千字节的内存.有了表，我们只需为一个额外的表条目付出代价.一如既往，这些变化对你来说是看不见的，一切都会像以前一样继续工作.这些相对方法列表在今年晚些时候推出的新的操作系统版本上得到了支持.</p><p>当你使用相应的最小部署目标进行构建时，工具会自动在你的二进制文件中生成相对的方法列表，如果你需要针对老版本的OS，不用担心, Xcode也会生成老式的方法列表格式.你仍然可以从操作系统本身的构建中获得新的相对方法列表的好处，而且系统在同一应用程序中同时使用两种格式也没有问题.不过如果你能针对今年的OS版本构建，你会得到更小的二进制文件和更少的内存使用.
这在Objective-C或Swift中是一个普遍不错的提示.最小部署目标并不只是关于哪些SDK API可以给你使用.当Xcode知道它不需要支持旧的操作系统版本时，它通常可以发出更好的优化代码或数据.我们理解你们中的许多人需要支持旧的OS版本，但这也是为什么无论何时增加部署目标都是一个好主意的原因.现在，有一件事需要注意，那就是使用比你打算使用的部署目标更新的部署目标进行构建.Xcode通常会防止这种情况发生，但也有可能漏掉，特别是当你在其他地方构建自己的库或框架，然后将它们带进来的时候.当运行在旧的操作系统上时，旧的运行时会看到这些相对方法，但它对它们一无所知，所以它会尝试像解释旧式的基于指针的方法一样解释它们.这意味着它将尝试把一对32位的字段作为64位的指针来读取.结果是两个整数被粘在一起作为一个指针，这是一个无意义的值，如果真的使用它，肯定会崩溃.你可以通过运行时读取方法信息时的崩溃来识别这种情况的发生，一个坏的指针看起来就像两个32bit的值被平滑在一起，就像这个例子.
<img src=./15933251515193/15933404013134.png alt></p><p>如果你运行的代码挖掘这些结构来读出值，那这段代码就会出现和这些旧运行时一样的问题，当用户升级设备时，App就会崩溃.所以，还是不要这样做&ndash;使用API.不管底层的东西怎么变，那些API都能继续工作. 例如，有一些函数，给定一个方法指针就会返回其字段的值.</p><h2 id=tagged-pointer变化>Tagged Pointer变化</h2><p>我们再来探讨一下今年即将到来的一个变化：ARM64上<code>Tagged Pointer</code>格式的变化.首先，我们需要知道什么是<code>Tagged Pointer</code>.
我们将在这里探索底层真正的实现，但不要担心&ndash;就像我们谈过的其他事情一样，你不需要知道这些.它只是很有趣&ndash;也许能帮助你更好地理解你的内存使用情况.让我们从普通对象指针的结构开始.
通常，当我们看到这些指针时，它们被打印成这些大的十六进制数字.我们在前面看到了一些这样的东西.让我们把它分解成二进制表示.
<img src=./15933251515193/15933404859945.png alt>
我们有64位的空间.然而，我们并没有真正使用所有这些位.只有中间的几位在真正的对象指针中被设置.低位总是0，因为对齐要求：对象必须总是位于一个指针大小的倍数的地址中.高位总是0，因为地址空间是有限的：我们实际上不会用到2^64.这些高位和低位总是0.
所以让我们从这些始终为0的位子中挑出一个位子，让它变成1.这可以立即告诉我们这不是一个真正的对象指针，然后我们可以给所有其他位子赋予一些其他的意义.我们称之为<code>Tagged Pointer</code>.
<img src=./15933251515193/%E6%88%AA%E5%B1%8F2020-06-28%2018.35.49.png alt="截屏2020-06-28 18.35.49"></p><p>例如，我们可以在其他位中塞入一个数值.只要我们想教NSNumber如何读取这些位，并让运行时适当地处理标签指针，系统的其他部分就可以把这些东西当做对象指针来处理，永远不会知道其中的区别.而这也为我们节省了为每一种这样的情况分配一个微小的数字对象的开销，这可能是一个重大的改进.这些值实际上是通过将它们与一个进程启动时初始化的随机值相结合来混淆的, 这是一种安全措施，它使伪造标记指针值变得困难.
<img src=./15933251515193/%E6%88%AA%E5%B1%8F2020-06-28%2018.36.11.png alt="截屏2020-06-28 18.36.11"></p><p>在接下来的讨论中，我们将忽略这一点，因为它只是在上面增加了一层.只是要注意，如果你真的试图在内存中查看这些值，它们会被扰乱.所以这就是Intel上标记指针的完整格式.低位被设置为1，表示这是一个<code>Tagged Pointer</code>.正如我们讨论过的，对于一个真实的指针来说，这个位必须始终为0，所以这让我们可以区分它们.接下来的3位是标签号.这表示标记指针的类型.例如，3表示它是一个NSNumber，6表示它是一个NSDate.由于我们有3个标签位，所以有8种可能的标签类型.其余的位是有效载荷(payload), 这是特定类型可以随意使用的数据.对于标记的NSNumber，这是实际的数字.
<img src=./15933251515193/15933407448038.png alt>
现在标签7有一个特殊情况.这表示一个扩展标签.扩展标签使用下一个八位来对类型进行编码，允许多出256个标签类型，但代价是减少有效载荷.这使得我们可以将标签指针用于更多的类型，只要它们能够将其数据装入更小的空间.这被用于像标记<code>UlColor</code>或<code>NSIndexSet</code>这样的东西.如果这对你来说非常方便，你可能会失望地听到只有运行时维护者&ndash;也就是苹果&ndash;可以添加<code>Tagged Pointer</code>类型.</p><p>但如果你是一个Swift程序员，你会很高兴地知道你可以创建自己的标签指针类型. 如果你曾经使用过一个具有关联值的枚举，那就是一个类似于<code>Tagged Pointer</code>的类.Swift运行时将枚举判别器存储在关联值有效载荷的备用位中.更重要的是，Swift对值类型的使用实际上使<code>Tagged Pointer</code>变得不那么重要了，因为值不再需要完全是指针大小.例如，Swift的UUID类型可以是两个字，并保持在内联，而不是分配一个单独的对象，因为它不适合在一个指针里面.
这就是英特尔上的标记指针.我们来看看ARM.在ARM64上，苹果把事情翻转过来了.</p><p><img src=./15933251515193/15933408987373.png alt></p><p>最高位(而不是最低位)被设置为1，表示一个<code>Tagged Pointer</code>.然后标签号在接下来的三个位中出现.然后，有效载荷使用剩余的位.为什么苹果在ARM上使用顶部位来指示标记指针，而不是像在英特尔上那样使用底部位？嗯，这实际上是对objc_msgSend的一个小小的优化.苹果希望msgSend中最常见的路径尽可能快.而最常见的路径是一个普通的指针.我们有两种不太常见的情况：<code>Tagged Pointer</code>和nil.事实证明，当我们使用最高位时，我们可以通过一次比较来检查这两种情况.而且在msgSend中，这样就为常见的情况节省了一个条件分支，而不是分别检查nil和<code>Tagged Pointer</code>.就像在英特尔上，对标签7表示一个特殊的情况，接下来的8位被用作扩展标签，然后剩下的位被用于有效载荷.或者说这其实是旧的格式，在iOSl3中使用.在今年的版本中.我们把东西移动了一下! 标签位保持在最高位，因为那个msgSend的优化还是非常有用的.标签号现在移到了最下面的三个位.
扩展标签如果使用，则占据标签位后的高八位.
<img src=./15933251515193/%E6%88%AA%E5%B1%8F2020-06-28%2018.42.28.png alt="截屏2020-06-28 18.42.28"></p><p><strong>为什么要这样做呢</strong>？好吧，我们再考虑一个普通的指针.我们现有的工具，比如动态链接器，由于ARM的一个名为Top Byte Ignore的特性，忽略了指针的前8位.而我们会把扩展标签放在Top Byte Ignore位.对于一个对齐的指针来说，底部三个位总是0.但我们可以通过在指针中添加一个小数字来改变这一点.
<img src=./15933251515193/15933410970189.png alt></p><p>我们将添加7来将低位设置为1.请记住，7 表示这是一个扩展标记.这意味着我们实际上可以将上面的这个指针放入一个扩展标签指针有效载荷中.结果就是一个标签指针，其有效载荷中包含一个普通指针.为什么这很有用呢？嗯，它开启了标记指针引用二进制中的常量数据的能力，例如字符串或其他数据结构，否则它们将不得不占用肮脏的内存.当然，现在这些变化意味着，当iOSl4今年晚些时候发布时，直接访问这些位的代码将不再工作.像这样的位检查在过去是可以工作的，但在未来的操作系统上会给你错误的答案，你的App会开始神秘地破坏用户数据.所以不要使用依赖于我们刚才谈到的任何代码.相反，你大概可以猜到我要说什么：也就是使用API.像isKindOfClass：这样的类型检查在旧的标记指针格式上工作，它们将继续在新的标记指针格式上工作. 所有的NSString或NSNumber方法都能继续工作.这些标记指针中的所有信息都可以通过标准的API来检索.
值得注意的是，这也适用于CF类型.苹果表示他们不想隐藏任何东西，也绝对不想破坏任何人的Apps. 当这些细节没有暴露出来的时候，只是因为他们需要保持灵活性来进行这样的改变，只要你的App不依赖这些内部细节，你的App就会继续正常工作.</p><p>那么，我们来总结一下.在这次Session中，我们已经看到了一些幕后的改进，这些改进缩小了我们运行时的开销，将更多的内存留给你和你的用户.你不需要做任何事情就能获得这些改进&ndash;除了可能考虑提高你的deployment target.</p></article><article id=egnvzgxnvjbor5hogjfml7bkvjjljjy><h2 class=major>xcode编译耗时优化</h2><span class="image main"><img src alt></span><p>前戏太长, 容易疲软. 几乎每一个iOSer都会时不时地遭受Xcode构建时间过长的困扰. 它直接导致生产率的降低，并拖慢了整个团队的开发进程, 影响coding辛福感.
跟做app性能提升类似, 优化编译时间在很大程度上需要的是耐心、严谨和毅力，要仔细、持续地测量. 是一个逐步消除噪音，集中精力去分析一个信号的过程.</p><blockquote><p>环境配置
Apple Swift version 5.2.4 (swiftlang-1103.0.32.9 clang-1103.0.32.53)
Target: x86_64-apple-darwin19.5.0</p></blockquote><h2 id=量化>量化</h2><p>在开始之前先来看看如何量化这部分的数据. 一方面这些数据帮助我们更精确地度量优化的效果,集中精力focus具体的可优化项; 另一方面或许你的晋升或KPI总结里需要这部分内容.</p><ul><li><p>直接查看Report Navigator中的日志, 是获取总的编译耗时最直接简单的方式.
<img src=https://raw.githubusercontent.com/lyn-euler/assets/master/img/report-log.jpg alt=-w300></p></li><li><p>另外也可以通过配置ShowBuildOperationDuration来开启activity viewer中的编译耗时视图</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>defaults write com.apple.dt.Xcode ShowBuildOperationDuration YES
</code></pre></div></li><li><p>当然这只能查看单个总耗时, 如果需要粒度更细的数据可以使用
<code>Product->Perform Action->Build With Timing Summary</code>编译工程(好像并没用),
或者添加命令行编译参数<code>-showBuildTimingSummary</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>xcodebuild -project <span style=color:#e6db74>&#39;xxx.xcodeproj&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>-scheme <span style=color:#e6db74>&#39;xxx&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>-configuration <span style=color:#e6db74>&#39;Debug&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>-sdk <span style=color:#e6db74>&#39;iphonesimulator&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>-showBuildTimingSummary <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>clean build
</code></pre></div><p>这样就可以获取每个阶段的耗时了, 然后针对每个耗时较长的阶段进行优化.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>Build Timing Summary
  
CompileSwiftSources (4 tasks) | 141.310 seconds
  
CompileStoryboard (29 tasks) | 70.919 seconds
  
CompileAssetCatalog (2 tasks) | 26.859 seconds
  
PhaseScriptExecution (5 tasks) | 8.331 seconds
  
CodeSign (7 tasks) | 7.136 seconds
  
CompileXIB (21 tasks) | 6.603 seconds
  
Ld (4 tasks) | 2.880 seconds
  
Ditto (28 tasks) | 0.197 seconds
  
CompileC (3 tasks) | 0.134 seconds
  
LinkStoryboards (2 tasks) | 0.111 seconds
  
Touch (4 tasks) | 0.012 seconds
  
** BUILD SUCCEEDED ** [195.974 sec]
</code></pre></div></li></ul><h3 id=other-swift-flags>Other Swift Flags</h3><p>如果Swift是编译瓶颈, 还可以通过添加编译器参数来获取更精确的信息</p><ul><li><code>-driver-time-compilation</code></li><li><code>-Xfrontend -debug-time-compilation</code></li><li><code>-Xfrontend -debug-time-function-bodies</code> 或 <code>-Xfrontend -warn-long-function-bodies=xxx</code></li><li><code>-Xfrontend -debug-time-expression-type-checking</code> 或 <code>-Xfrontend -warn-long-expression-type-checking=xxx</code></li><li><code>-Xfrontend -print-stats</code></li><li><code>-Xfrontend -print-clang-stats</code></li><li><code>-Xfrontend -print-stats -Xfrontend -print-inst-counts</code></li></ul><p>比如通过<code>-driver-time-compilation</code>获取Driver Job的耗时</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>xcodebuild -project <span style=color:#e6db74>&#39;clutter.xcodeproj&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>-scheme <span style=color:#e6db74>&#39;clutter&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>-configuration <span style=color:#e6db74>&#39;Debug&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>-sdk <span style=color:#e6db74>&#39;iphonesimulator&#39;</span>  <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>clean build <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>OTHER_SWIFT_FLAGS<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;-driver-time-compilation&#34;</span> 
</code></pre></div><p>执行后就可以从日志中提取相关数据.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#f92672>===-------------------------------------------------------------------------===</span>
                            <span style=color:#a6e22e>Driver</span> <span style=color:#a6e22e>Compilation</span> <span style=color:#a6e22e>Time</span>
<span style=color:#f92672>===-------------------------------------------------------------------------===</span>
  <span style=color:#a6e22e>Total</span> <span style=color:#a6e22e>Execution</span> <span style=color:#a6e22e>Time</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0.0023</span> <span style=color:#a6e22e>seconds</span> (<span style=color:#ae81ff>0.6612</span> <span style=color:#a6e22e>wall</span> <span style=color:#a6e22e>clock</span>)

   <span style=color:#f92672>---</span><span style=color:#a6e22e>User</span> <span style=color:#a6e22e>Time</span><span style=color:#f92672>---</span>   <span style=color:#f92672>--</span><span style=color:#a6e22e>System</span> <span style=color:#a6e22e>Time</span><span style=color:#f92672>--</span>   <span style=color:#f92672>--</span><span style=color:#a6e22e>User</span><span style=color:#f92672>+</span><span style=color:#a6e22e>System</span><span style=color:#f92672>--</span>   <span style=color:#f92672>---</span><span style=color:#a6e22e>Wall</span> <span style=color:#a6e22e>Time</span><span style=color:#f92672>---</span>  <span style=color:#f92672>---</span> <span style=color:#a6e22e>Name</span> <span style=color:#f92672>---</span>
   <span style=color:#ae81ff>0.0002</span> ( <span style=color:#ae81ff>21.8</span><span style=color:#f92672>%</span>)   <span style=color:#ae81ff>0.0002</span> ( <span style=color:#ae81ff>18.3</span><span style=color:#f92672>%</span>)   <span style=color:#ae81ff>0.0005</span> ( <span style=color:#ae81ff>19.8</span><span style=color:#f92672>%</span>)   <span style=color:#ae81ff>0.1845</span> ( <span style=color:#ae81ff>27.9</span><span style=color:#f92672>%</span>)  {<span style=color:#a6e22e>compile</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>TestViewController</span>.<span style=color:#a6e22e>o</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>TestViewController</span>.<span style=color:#a6e22e>swift</span> }
   <span style=color:#ae81ff>0.0003</span> ( <span style=color:#ae81ff>27.5</span><span style=color:#f92672>%</span>)   <span style=color:#ae81ff>0.0004</span> ( <span style=color:#ae81ff>31.7</span><span style=color:#f92672>%</span>)   <span style=color:#ae81ff>0.0007</span> ( <span style=color:#ae81ff>30.0</span><span style=color:#f92672>%</span>)   <span style=color:#ae81ff>0.1641</span> ( <span style=color:#ae81ff>24.8</span><span style=color:#f92672>%</span>)  {<span style=color:#a6e22e>compile</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>TestSwiftObject</span>.<span style=color:#a6e22e>o</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>TestSwiftObject</span>.<span style=color:#a6e22e>swift</span> }
   <span style=color:#ae81ff>0.0001</span> (  <span style=color:#ae81ff>8.1</span><span style=color:#f92672>%</span>)   <span style=color:#ae81ff>0.0000</span> (  <span style=color:#ae81ff>2.3</span><span style=color:#f92672>%</span>)   <span style=color:#ae81ff>0.0001</span> (  <span style=color:#ae81ff>4.7</span><span style=color:#f92672>%</span>)   <span style=color:#ae81ff>0.1481</span> ( <span style=color:#ae81ff>22.4</span><span style=color:#f92672>%</span>)  {<span style=color:#a6e22e>merge</span><span style=color:#f92672>-</span><span style=color:#a6e22e>module</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>clutter</span>.<span style=color:#a6e22e>swiftmodule</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>TestS</span>.<span style=color:#a6e22e>o</span> <span style=color:#a6e22e>TestSwiftObject</span>.<span style=color:#a6e22e>o</span> <span style=color:#a6e22e>TestViewController</span>.<span style=color:#a6e22e>o</span>}
   <span style=color:#ae81ff>0.0003</span> ( <span style=color:#ae81ff>31.3</span><span style=color:#f92672>%</span>)   <span style=color:#ae81ff>0.0006</span> ( <span style=color:#ae81ff>43.2</span><span style=color:#f92672>%</span>)   <span style=color:#ae81ff>0.0009</span> ( <span style=color:#ae81ff>38.2</span><span style=color:#f92672>%</span>)   <span style=color:#ae81ff>0.1435</span> ( <span style=color:#ae81ff>21.7</span><span style=color:#f92672>%</span>)  {<span style=color:#a6e22e>compile</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>TestS</span>.<span style=color:#a6e22e>o</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>TestS</span>.<span style=color:#a6e22e>swift</span> }
   <span style=color:#ae81ff>0.0001</span> ( <span style=color:#ae81ff>11.3</span><span style=color:#f92672>%</span>)   <span style=color:#ae81ff>0.0001</span> (  <span style=color:#ae81ff>4.4</span><span style=color:#f92672>%</span>)   <span style=color:#ae81ff>0.0002</span> (  <span style=color:#ae81ff>7.3</span><span style=color:#f92672>%</span>)   <span style=color:#ae81ff>0.0210</span> (  <span style=color:#ae81ff>3.2</span><span style=color:#f92672>%</span>)  {<span style=color:#a6e22e>generate</span><span style=color:#f92672>-</span><span style=color:#a6e22e>pch</span><span style=color:#f92672>:</span>  <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>clutter</span><span style=color:#f92672>-</span><span style=color:#a6e22e>Bridging</span><span style=color:#f92672>-</span><span style=color:#a6e22e>Header</span>.<span style=color:#a6e22e>h</span>}
   <span style=color:#ae81ff>0.0010</span> (<span style=color:#ae81ff>100.0</span><span style=color:#f92672>%</span>)   <span style=color:#ae81ff>0.0013</span> (<span style=color:#ae81ff>100.0</span><span style=color:#f92672>%</span>)   <span style=color:#ae81ff>0.0023</span> (<span style=color:#ae81ff>100.0</span><span style=color:#f92672>%</span>)   <span style=color:#ae81ff>0.6612</span> (<span style=color:#ae81ff>100.0</span><span style=color:#f92672>%</span>)  <span style=color:#a6e22e>Total</span>
</code></pre></div><p>甚至可以获取某个函数或者表达式类型检查的耗时.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>xcodebuild -project <span style=color:#e6db74>&#39;clutter.xcodeproj&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>-scheme <span style=color:#e6db74>&#39;clutter&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>-configuration <span style=color:#e6db74>&#39;Debug&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>-sdk <span style=color:#e6db74>&#39;iphonesimulator&#39;</span>  <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>clean build  <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>OTHER_SWIFT_FLAGS<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;-Xfrontend -debug-time-expression-type-checking \
</span><span style=color:#e6db74>-Xfrontend -debug-time-function-bodies&#34;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>| grep -o <span style=color:#e6db74>&#34;^\d*.\d*ms\t[^</span>$<span style=color:#e6db74>]*</span>$<span style=color:#e6db74>&#34;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>| awk <span style=color:#e6db74>&#39;!visited[$0]++&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>| sed -e <span style=color:#e6db74>&#34;s|</span><span style=color:#66d9ef>$(</span>pwd<span style=color:#66d9ef>)</span><span style=color:#e6db74>/||&#34;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>| sort -rn <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>| head -5
  
0.60ms	clutter/TestViewController.swift:15:19	instance method viewDidLoad<span style=color:#f92672>()</span>
0.51ms	clutter/TestViewController.swift:16:15
0.02ms	clutter/TestSwiftObject.swift:11:33	initializer init<span style=color:#f92672>()</span>
0.02ms	clutter/TestS.swift:12:9	getter aaa
0.02ms	TestSymbol/TestB.swift:12:9	getter b
</code></pre></div><h3 id=可视化工具>可视化工具</h3><p>上面都是一些日志输出的量化方式需要自己从日志中提取信息, 下面介绍几个可视化工具.</p><h4 id=profiler---counter--perf>Profiler - Counter & perf</h4><p><code>Instruments.app</code>内置了一个<code>Counters</code>工具, 可以通过 Xcode => Open Developer Tool => Instruments => Counters 开启. 不过该工具会记录所有进程的数据, 干扰项比较多
<img src=https://raw.githubusercontent.com/lyn-euler/assets/master/img/instrument-counters.png alt></p><p><strong>perf</strong> 是一款Linux下的profiler. 可以直接在命令行中使用它.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>perf record -e cycles -c <span style=color:#ae81ff>10000</span> --call-graph<span style=color:#f92672>=</span>lbr swiftc t.swift
</code></pre></div><p><img src=https://raw.githubusercontent.com/lyn-euler/assets/master/img/PerfReport.png alt></p><h3 id=xcode-build-timeshttpsgithubcompaultaykaloxcode-build-times-rendering><a href=https://github.com/PaulTaykalo/xcode-build-times-rendering>xcode-build-times</a></h3><p>这是一款统计每个target编译耗时的工具.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#75715e># 安装</span>
gem install xcode-build-times
<span style=color:#75715e># 插入 build phases 脚本</span>
xcode-build-times install $PROJECT_PATH
<span style=color:#75715e># 收集数据</span>
xcode-build-times generate
</code></pre></div><p><img src=https://raw.githubusercontent.com/lyn-euler/assets/master/img/xcode-build-times.png alt></p><h3 id=xclogparserhttpsgithubcomspotifyxclogparser><a href=https://github.com/spotify/XCLogParser>XCLogParser</a></h3><p><strong>XCLogParser</strong>是一款可以解析SLF格式(存储Xcode build 和 test日志- xcactivitylog)的命令行工具. 这个工具提取的reporter很详细(强烈推荐).</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#75715e># 工具安装</span>
brew install xclogparser

<span style=color:#75715e># 日志解析</span>
xclogparser parse --project xxx.xcodeproj --reporter html
</code></pre></div><p><img src=https://raw.githubusercontent.com/lyn-euler/assets/master/img/xclogparser.png alt></p><h2 id=优化内容>优化内容</h2><h3 id=设置项优化>设置项优化</h3><ul><li><p>DEBUG编译模式ONLY_ACTIVE_ARCH设置为Yes.</p></li><li><p>设置SWIFT_COMPILATION_MODE, Debug:Incremental, Release:Whole Module.
swift的编译前端很大不同有这两种编译模式决定
<img src=https://raw.githubusercontent.com/lyn-euler/assets/master/img/swift-compile-mode.png alt></p></li><li><p>SWIFT_OPTIMIZATION_LEVEL, Debug: No Optimization, Release: Optimize for Speed</p></li><li><p>DEBUG_INFORMATION_FORMAT Debug: DWARF, Release: DWARF with dSYM</p></li><li><p>优化Search path</p></li></ul><h3 id=源码优化>源码优化</h3><ul><li><p>控制代码粒度(比如给每个实体单独使用一个文件,为你的类、结构、枚举、扩展等使用正确的访问修饰符), 降低文件修改造成的影响, 减少rebuild的范围.</p></li><li><p>forward declaration, 使用<code>@class</code>而不是 <code>#import</code>.</p></li><li><p>正确使用pch文件</p></li><li><p>移除无用代码</p></li><li><p>预编译相关依赖</p></li><li><p>使用代码而不是xib或者Storyboard</p></li><li><p>表达式和函数优化
这里可以执行</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>swiftc -Xfrontend -debug-time-function-bodies xxx.swift
</code></pre></div><p>查看这两种方式的编译耗时.</p><ol><li>减少类型推断</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift>  <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>typeAnnotaions</span>() {
      <span style=color:#66d9ef>let</span> arr: [String] = [<span style=color:#e6db74>&#34;a&#34;</span>, <span style=color:#e6db74>&#34;b&#34;</span>, <span style=color:#e6db74>&#34;c&#34;</span>, <span style=color:#e6db74>&#34;d&#34;</span>]
      print(arr)
  }
  <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>noTypeAnnotaions</span>() {
      <span style=color:#66d9ef>let</span> arr = [<span style=color:#e6db74>&#34;a&#34;</span>, <span style=color:#e6db74>&#34;b&#34;</span>, <span style=color:#e6db74>&#34;c&#34;</span>, <span style=color:#e6db74>&#34;d&#34;</span>]
      print(arr)
  }
  
<span style=color:#75715e>/*****************************
</span></code></pre></div></li></ul><p>0.24ms TestSwiftA.swift:12:10 instance method typeAnnotaions()
1.79ms TestSwiftA.swift:16:10 instance method noTypeAnnotaions()
*/</p><pre><code>1. 避免空操作

  ```swift
  func nilCoalescing() {
      let string: String? = &quot;&quot;
      if let _ = string{
       /* string has value */
      }else{
       /* string is nil*/
      }
  }
  func noNilCoalescing() {
      let string: String? = &quot;&quot;
      let _ = string ?? &quot;&quot;
  }
  /*****************************
  2.28ms	TestSwiftA.swift:21:10	instance method nilCoalescing()
0.98ms	TestSwiftA.swift:29:10	instance method noNilCoalescing()
  */
  ```
1. `if-else` 比三元运算符`?:`要快一点

2. 提前计算结果

```swift
func preCompute()  {
      let num: Int = 3600
      print(num)
  }
  func noPreCompute()  {
      let num: Int = 60 * 60
      print(num)
  }
/*****************************
2.03ms	TestSwiftA.swift:49:10	instance method preCompute()
67.48ms	TestSwiftA.swift:53:10	instance method noPreCompute()
*/
</code></pre><ol><li><code>append</code>并没有比<code>+</code>更快</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>arrPSymbol</span>()  {
      <span style=color:#66d9ef>var</span> arr1 = [<span style=color:#e6db74>&#34;a&#34;</span>]
      <span style=color:#66d9ef>let</span> arr2 = [<span style=color:#e6db74>&#34;b&#34;</span>]
      arr1 <span style=color:#f92672>+=</span> arr2
      print(arr1)
  }
  <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>arrAppend</span>()  {
      <span style=color:#66d9ef>var</span> arr1 = [<span style=color:#e6db74>&#34;a&#34;</span>]
      <span style=color:#66d9ef>let</span> arr2 = [<span style=color:#e6db74>&#34;b&#34;</span>]
      arr1.append(contentsOf: arr2)
      print(arr1)
  }
  <span style=color:#75715e>/***********************
</span><span style=color:#75715e>  25.72ms    TestSwiftA.swift:75:10    instance method arrPSymbol()
</span><span style=color:#75715e>  27.89ms    TestSwiftA.swift:81:10    instance method arrAppend()
</span><span style=color:#75715e>  */</span>
</code></pre></div><ol><li>三种lazy property的写法也并不如同网上说的</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>private</span>(<span style=color:#66d9ef>set</span>) <span style=color:#66d9ef>lazy</span> <span style=color:#66d9ef>var</span> propertyColors: [UIColor] = [
      UIColor(red: <span style=color:#ae81ff>86</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, green: <span style=color:#ae81ff>84</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, blue: <span style=color:#ae81ff>124</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, alpha: <span style=color:#ae81ff>1</span>),
      UIColor(red: <span style=color:#ae81ff>80</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, green: <span style=color:#ae81ff>88</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, blue: <span style=color:#ae81ff>92</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, alpha: <span style=color:#ae81ff>1</span>),
      UIColor(red: <span style=color:#ae81ff>126</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, green: <span style=color:#ae81ff>191</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, blue: <span style=color:#ae81ff>189</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, alpha: <span style=color:#ae81ff>1</span>),
      UIColor(red: <span style=color:#ae81ff>161</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, green: <span style=color:#ae81ff>77</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, blue: <span style=color:#ae81ff>63</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, alpha: <span style=color:#ae81ff>1</span>),
      UIColor(red: <span style=color:#ae81ff>235</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, green: <span style=color:#ae81ff>185</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, blue: <span style=color:#ae81ff>120</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, alpha: <span style=color:#ae81ff>1</span>),
      UIColor(red: <span style=color:#ae81ff>100</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, green: <span style=color:#ae81ff>126</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, blue: <span style=color:#ae81ff>159</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, alpha: <span style=color:#ae81ff>1</span>),
      UIColor(red: <span style=color:#ae81ff>160</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, green: <span style=color:#ae81ff>209</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, blue: <span style=color:#ae81ff>109</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, alpha: <span style=color:#ae81ff>1</span>),
  ]
  
  
  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>let</span> closureColors = { () -&gt; [UIColor] <span style=color:#66d9ef>in</span>
      <span style=color:#66d9ef>let</span> colors = [
          UIColor(red: <span style=color:#ae81ff>86</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, green: <span style=color:#ae81ff>84</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, blue: <span style=color:#ae81ff>124</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, alpha: <span style=color:#ae81ff>1</span>),
          UIColor(red: <span style=color:#ae81ff>80</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, green: <span style=color:#ae81ff>88</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, blue: <span style=color:#ae81ff>92</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, alpha: <span style=color:#ae81ff>1</span>),
          UIColor(red: <span style=color:#ae81ff>126</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, green: <span style=color:#ae81ff>191</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, blue: <span style=color:#ae81ff>189</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, alpha: <span style=color:#ae81ff>1</span>),
          UIColor(red: <span style=color:#ae81ff>161</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, green: <span style=color:#ae81ff>77</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, blue: <span style=color:#ae81ff>63</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, alpha: <span style=color:#ae81ff>1</span>),
          UIColor(red: <span style=color:#ae81ff>235</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, green: <span style=color:#ae81ff>185</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, blue: <span style=color:#ae81ff>120</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, alpha: <span style=color:#ae81ff>1</span>),
          UIColor(red: <span style=color:#ae81ff>100</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, green: <span style=color:#ae81ff>126</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, blue: <span style=color:#ae81ff>159</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, alpha: <span style=color:#ae81ff>1</span>),
          UIColor(red: <span style=color:#ae81ff>160</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, green: <span style=color:#ae81ff>209</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, blue: <span style=color:#ae81ff>109</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, alpha: <span style=color:#ae81ff>1</span>),
      ]
      <span style=color:#66d9ef>return</span> colors
  }
  
  <span style=color:#66d9ef>private</span>(<span style=color:#66d9ef>set</span>) <span style=color:#66d9ef>lazy</span> <span style=color:#66d9ef>var</span> funcColors: [UIColor] = _createColors()
  
  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>_createColors</span>() -&gt; [UIColor] {
      <span style=color:#66d9ef>return</span> [
          UIColor(red: <span style=color:#ae81ff>86</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, green: <span style=color:#ae81ff>84</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, blue: <span style=color:#ae81ff>124</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, alpha: <span style=color:#ae81ff>1</span>),
          UIColor(red: <span style=color:#ae81ff>80</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, green: <span style=color:#ae81ff>88</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, blue: <span style=color:#ae81ff>92</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, alpha: <span style=color:#ae81ff>1</span>),
          UIColor(red: <span style=color:#ae81ff>126</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, green: <span style=color:#ae81ff>191</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, blue: <span style=color:#ae81ff>189</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, alpha: <span style=color:#ae81ff>1</span>),
          UIColor(red: <span style=color:#ae81ff>161</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, green: <span style=color:#ae81ff>77</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, blue: <span style=color:#ae81ff>63</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, alpha: <span style=color:#ae81ff>1</span>),
          UIColor(red: <span style=color:#ae81ff>235</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, green: <span style=color:#ae81ff>185</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, blue: <span style=color:#ae81ff>120</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, alpha: <span style=color:#ae81ff>1</span>),
          UIColor(red: <span style=color:#ae81ff>100</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, green: <span style=color:#ae81ff>126</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, blue: <span style=color:#ae81ff>159</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, alpha: <span style=color:#ae81ff>1</span>),
          UIColor(red: <span style=color:#ae81ff>160</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, green: <span style=color:#ae81ff>209</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, blue: <span style=color:#ae81ff>109</span><span style=color:#f92672>/</span><span style=color:#ae81ff>255</span>, alpha: <span style=color:#ae81ff>1</span>),
      ]
  }
  <span style=color:#75715e>/*
</span><span style=color:#75715e>   0.03ms    TestSwiftA.swift:93:27    getter propertyColors
</span><span style=color:#75715e>   0.01ms    TestSwiftA.swift:93:27    setter propertyColors
</span><span style=color:#75715e>   0.03ms    TestSwiftA.swift:93:27    _modify accessor propertyColors
</span><span style=color:#75715e>   ===============
</span><span style=color:#75715e>   0.01ms    TestSwiftA.swift:103:17    getter closureColors
</span><span style=color:#75715e>   ===============
</span><span style=color:#75715e>   0.01ms    TestSwiftA.swift:117:27    getter funcColors
</span><span style=color:#75715e>   0.01ms    TestSwiftA.swift:117:27    setter funcColors
</span><span style=color:#75715e>   0.01ms    TestSwiftA.swift:117:27    _modify accessor funcColors
</span><span style=color:#75715e>   0.02ms    TestSwiftA.swift:119:18    instance method _createColors()
</span><span style=color:#75715e>   */</span>
</code></pre></div><h3 id=工程改进>工程改进</h3><ul><li>组件化(单组件开发, 减少开发依赖)</li><li>使用静态库/动态库(对于组件多的大型工程, 这里提升应该是非常可观的)</li><li>优化Run Script phases </li><li>控制模块拆分粒度(比如颗粒度更细的模块, 可以有效利用多任务)</li></ul><h3 id=工具或其他>工具或其他</h3><ul><li>编译器改进</li><li>Buck/Bazel</li><li>CCache(缓存)</li><li>distcc(分布式编译工具)</li><li>Preview(Swift UI), HotReload(Flutter).</li><li>升级硬件</li></ul><h2 id=参考文档>参考文档</h2><ul><li><a href=https://hackernoon.com/speed-up-swift-compile-time-6f62d86f85e6>speed-up-swift-compile-time</a></li><li><a href=https://irace.me/swift-profiling>swift-profiling</a></li><li><a href=https://github.com/apple/swift/blob/master/docs/CompilerPerformance.md#diagnostic-options>Swift CompilerPerformance</a></li><li><a href=https://blog.csdn.net/zengconggen/article/details/73849670>如何将 iOS 项目的编译速度提高5倍</a></li></ul></article></div><footer id=footer><p class=copyright>&copy; Design: <a href=https://github.com/d-asnaghi>d-asnaghi</a> and <a href=https://html5up.net>HTML5 UP</a>.</p></footer></div><div id=bg></div></body><script src=./assets/js/jquery.min.js></script><script src=./assets/js/browser.min.js></script><script src=./assets/js/breakpoints.min.js></script><script src=./assets/js/util.js></script><script src=./assets/js/main.js></script></html>