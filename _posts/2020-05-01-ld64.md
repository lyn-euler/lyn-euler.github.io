# ld链接原理 & 优化方向

**Darwin Linker**是苹果推出的新一代链接器。区别于基于`section`的传统链接器(只是将多个目标文件中的`section`穿插到输出文件中), Darwin链接器是基于粒度更细的 `Atoms`工作的。虽然传统的基于`section`的链接器对于简单的链接来说效果很好，但是这样的模型使得一些高级链接功能难以实现。像dead code剥离、重新排序函数的位置以及`C++ coalescing`这样的特性就要求链接器在更精细的粒度上操作。

## Atom & Fixup
**一个`Atom`是指一个不可分割的代码或数据块**。通常情况下，每个用户编写的函数或全局变量都是一个`Atom`.此外，编译器也会引入(emit)一些其他的`Atom`，例如c字符串的字面量、浮点常数，以及一些运行时的数据结构，如调试信息(dwarf unwind info)或指向初始化器的指针.
一个`Atom`有一组属性，如：名称、范围、内容类型、对齐方式等。
```C
struct ld::Atom{
  const Section *						_section;
	uint64_t							_address;
	uint16_t							_alignmentModulus;
	uint8_t								_alignmentPowerOf2;
	Definition							_definition : 2;
	Combine								_combine : 2;
	bool								_dontDeadStrip : 1;
	bool								_thumb : 1; 
	bool								_alias : 1;
	int									_autoHide : 1;
	ContentType							_contentType : 5;
	SymbolTableInclusion				_symbolTableInclusion : 3;
	Scope								_scope : 2;
	AddressMode							_mode: 2;
	bool								_overridesADylibsWeakDef : 1;
	bool								_coalescedAway : 1;
	bool								_live : 1;
	bool								_dontDeadStripIfRefLive : 1;
	unsigned							_machoSection : 8;
	WeakImportState						_weakImportState : 2;
}
```

关键的`Atom`还有有一个Fixups列表。一个`Fixup`包含：种类、一个可选的偏移量、一个可选的addend和一个可选的目标`Atom`等。
```C++
struct ld::Fixup{
  union {
		const Atom*	target;
		const char*	name;
		uint64_t	addend;
		uint32_t	bindingIndex;
	} u;
	uint32_t		offsetInAtom;
	Kind			kind : 8;
	Cluster			clusterSize : 4;
	bool			weakImport : 1;
	TargetBinding	binding : 3;
	bool			contentAddendOnly : 1;
	bool			contentDetlaToAddendOnly : 1;
	bool			contentIgnoresAddend : 1;
}
```

基于此`Atom`模型允许链接器使用标准的图论模型(graph theory models)来链接数据结构。每个`Atom`是一个节点(node)，每个`Fixup`是一个edge。比如dead code剥离的特性就是通过跟随边缘标记所有活(live)的`Atom`，然后删除非活(non-live)的`Atom`来实现的。

比如下面这个简单源文件
```c
#include <stdio.h>
void test() {
    printf("Hello World");
}
```
在编译成目标文件后, 在参与链接时将被构建成
- 两个`Atom`:test和包含一个"hello world"字面量的匿名`Atom`; 
- 两个`Fixup`:一个调用`printf`的调用点(call site), 以及一个加载字符串地址的指令

<img style="width:400px;" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMjczcHgiIGhlaWdodD0iMTcycHgiIHZpZXdCb3g9IjAgMCAyNzMgMTcyIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA1NC4xICg3NjQ5MCkgLSBodHRwczovL3NrZXRjaGFwcC5jb20gLS0+CiAgICA8dGl0bGU+57yW57uEPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGcgaWQ9IumhtemdojEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSLnvJbnu4QiPgogICAgICAgICAgICA8cmVjdCBpZD0i55+p5b2iIiBzdHJva2Utb3BhY2l0eT0iMC41IiBzdHJva2U9IiMwMDAwMDAiIGZpbGw9IiNGRkZGRkYiIHg9IjAuNSIgeT0iMC41IiB3aWR0aD0iMTMyIiBoZWlnaHQ9IjUyIj48L3JlY3Q+CiAgICAgICAgICAgIDx0ZXh0IGlkPSJ0ZXN0IiBmb250LWZhbWlseT0iUGluZ0ZhbmdTQy1NZWRpdW0sIFBpbmdGYW5nIFNDIiBmb250LXNpemU9IjE0IiBmb250LXdlaWdodD0iNDAwIiBmaWxsPSIjMUExQTFBIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSI1NSIgeT0iMzEiPnRlc3Q8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDxyZWN0IGlkPSLnn6nlvaIiIHN0cm9rZS1vcGFjaXR5PSIwLjUiIHN0cm9rZT0iIzAwMDAwMCIgZmlsbD0iI0ZGRkZGRiIgeD0iMS41IiB5PSIxMTkuNSIgd2lkdGg9IjEzMiIgaGVpZ2h0PSI1MiI+PC9yZWN0PgogICAgICAgICAgICA8dGV4dCBpZD0iJnF1b3Q7SGVsbG8tV29ybGQmcXVvdDsiIGZvbnQtZmFtaWx5PSJQaW5nRmFuZ1NDLUxpZ2h0LCBQaW5nRmFuZyBTQyIgZm9udC1zaXplPSIxNCIgZm9udC13ZWlnaHQ9IjMwMCIgZmlsbD0iIzFBMUExQSI+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMjIiIHk9IjE1MSI+IjwvdHNwYW4+CiAgICAgICAgICAgICAgICA8dHNwYW4geD0iMjcuNDc0IiB5PSIxNTEiPkhlbGxvIFdvcmxkIjwvdHNwYW4+CiAgICAgICAgICAgIDwvdGV4dD4KICAgICAgICAgICAgPHBhdGggaWQ9IuebtOe6vyIgZD0iTTE0MS40ODQ0OTMsMTQ1LjQzOTMgTDIwMi40ODgyODEsMTQ1LjAwMzU1OSBMMjAyLjQ4ODI4MSwzNi41IEwxMzIuNDg4MjgxLDM2LjUgTDEzMi40ODgyODEsMzUuNSBMMjAzLjQ4ODI4MSwzNS41IEwyMDMuNDg4MjgxLDE0NS45OTY0NDEgTDE0MS40OTE2MzYsMTQ2LjQzOTI3NSBMMTQxLjUyMDIwNiwxNTAuNDM5MTcyIEwxMzIuNDg4Mjk0LDE0Ni4wMDM1NzEgTDE0MS40NTU5MjIsMTQxLjQzOTQwMiBMMTQxLjQ4NDQ5MywxNDUuNDM5MyBaIiBmaWxsPSIjOTc5Nzk3IiBmaWxsLXJ1bGU9Im5vbnplcm8iPjwvcGF0aD4KICAgICAgICAgICAgPHBhdGggaWQ9IuebtOe6vy0yIiBkPSJNMjIzLDE2LjUgTDEzMi40ODgyODEsMTYuNSBMMTMyLjQ4ODI4MSwxNS41IEwyMjMsMTUuNSBMMjIzLDExLjUgTDIzMiwxNiBMMjIzLDIwLjUgTDIyMywxNi41IFoiIGZpbGw9IiM5Nzk3OTciIGZpbGwtcnVsZT0ibm9uemVybyI+PC9wYXRoPgogICAgICAgICAgICA8dGV4dCBpZD0icHJpbnRmIiBmb250LWZhbWlseT0iUGluZ0ZhbmdTQy1NZWRpdW0sIFBpbmdGYW5nIFNDIiBmb250LXNpemU9IjE0IiBmb250LXdlaWdodD0iNDAwIiBmaWxsPSIjRjdCNTAwIj4KICAgICAgICAgICAgICAgIDx0c3BhbiB4PSIyMzciIHk9IjIxIj5wcmludGY8L3RzcGFuPgogICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4="/>

另外通过抽象`Atom`模型, 连接器的核心部分可以独立于架构和文件格式.所有的命令行解析都被事实化为一个独立的 "option"抽象，这使得链接器可以用不同的命令行集来驱动.

## ld链接过程
链接的过程可以归纳成如下步骤:
1. 命令行处理
2. 解析输入文件
3. 决议(Resolving)
4. Passes/Optimizations
5. 生成输出文件
其中Resolving和Passes的步骤都纯粹是在`Atom`的主图上完成的,所以它们没有mach-o或ELF等文件格式的概念.

### 文件模型
连接器的输入文件有三种类型: 目标文件、静态库和动态库.每一种文件都有一个reader object，它将输入文件解析成链接器所期望的模型。

- 目标文件

  一个目标文件只是一个`Atom`的容器. 当链接目标文件时，所有的`Atom`都会被添加到初始的`Atom`图中.
  
- 静态库

  这是传统的unix静态归档，它只是一个带有"table of contents"的目标文件的集合.当与静态库链接时，默认情况下不会在`Atom`初始图中添加任何东西.只有主图中的`Atom`存在着没有决议的引用（dangling edges）, 且对应的目标`Atom`在这个静态库里面的话，才会把对应的`Atom`的加入到主图内.
  
- 动态库

  动态库的独特之处在于，它不直接添加任何`Atom`.当主图中的`Atom`存在着没有决议的引用（dangling edges）, 且动态库导出一个所需的符号时, 链接器就会实例化一个"代理"的`Atom`.代理`Atom`允许主图中的所有edge都被解析，同时记录这个符号来自于哪个动态库.
  
### 决议(Resolving)
**Resolving**就是将所有目标文件生成的图中提取`Atom`并合并到一个主图中.当然并不是将每个文件中的`Atom`列表附加到一个大的列表中那么简单.比如一般还会涉及到`Atom`的coalesced(两个或更多的`Atom`凝聚成一个,比如:C语言的 "tentative definitions"，C++的弱符号和头文件中定义的inlines，以及c字符串和浮点常量等常量的合并拷贝).
ld支持按名和按内容合并。By-name用于"tentative definitions"和弱符号。By-content用于可以合并的常量数据。

当一个`Atom`对另一个`Atom`有引用（`Fixup`）时, 可以分为三种类型:
- 按名(By-name)
- 直接引用(direct)
- 间接引用(indirect)

分别对应上面union的`name`、`target`和`bindingIndex`.

输入文件`Atom`只包含直接引用和按名引用。直接引用用于在同一目标文件中定义的`Atom`，而target是未命名或不能改变的。例如，在翻译单元中调用一个静态函数，会直接引用到静态函数的`Atom`。同样，一个函数的FDE（dwarf unwind info）也会直接引用到它的函数。另一方面，对全局符号的引用（如对printf的调用）使用目标文件中的by-name绑定。

Resolving的过程维护着一些全局链接的"state"，包括：
- 一个 "符号表"，它是一个从c-string到`Atom*`的映射;
- 一个间接符号表，它是一个可增长的`Atom*`数组, 对于每一种可合并的常量都有一个内容到`Atom*`的映射。
通过这些数据结构，链接器遍历所有输入文件中的所有`Atom`。对于每一个`Atom`，它检查该`Atom`是否应该在一个符号表或一个凝聚表中。如果是，它尝试添加该`Atom`。如果在该表中已经有一个匹配的`Atom`，那就意味着当前的`Atom`需要与找到的`Atom`进行整合。

为了支持coalescing，所有对可coalesable atom的引用都被改为间接绑定，并在间接表中添加一个指向当前选择的`Atom`的条目。当解析器处理完所有输入`Atom`后，应该只剩下直接绑定和间接绑定。如果间接表中有任何 NULL 条目，意味着存在未定义的引用。然后链接器会查找所提供的库（包括静态和动态）来resolve这些引用。

**Dead code stripping**(如果要求的话）会在Resolving结束后进行。链接器做一个简单的标记和扫描。就是从一个root atom遍历图节点, 并将每个访问到的节点打上标记, 最后将没有标记的删除掉。

## Passes
**Passes**步骤是一组开放的例程，每个例程中都可以修改或增强`Atom`主图。Passes只有在`Atom`主图完全解析（no dangling edges）的情况下才会运行。目前ld中的Passes的集合有:
- Objective-C optimizations (Apple)
- stub (PLT) generation
- GOT instantiation
- TLV instantiation (Apple)
- order_file optimization
- branch island generation
- branch shim generation
- dtrace probe processing (Apple)
- compact unwind encoding (Apple)

其中有标记`Apple`是Apple公司运行时环境所特有的.

通行证的一般结构是在主图上遍历检查每个`Atom`，并做一些事情。例如，stub pass，遍历图，寻找具有proxy的调用点的`Atom`（例如调用到printf）。然后，它为每个需要代理`Atom`实例化一个 "stub "`Atom`（PLT条目）和一个 "lazy pointer "`Atom`，这些新的`Atom`被添加到主图中。接下来，所有proxy atom的调用点都被替换为相应的stub atom的调用。

## 生成输出文件
**Passes**完成后，输出文件生成器会得到一个排序好的`Atom`列表。最后它会将`Atom`列表生成可执行文件输出.

## ld速度优化
上面简单介绍了ld的工作原理, 基于此我们可以做一些优化措施:

#### 修改输入文件格式
目前在mach-o .o文件中使用section的做法对链接器造成了过度的限制。默认情况下，链接器应该保留一个`Atom`所在的section。但是，由于所有section在输出中必须是毗连的，这就限制了链接器对`Atom`的位置进行排序的能力。
同时链接器必须对mach-o .o文件进行解析&处理是产生耗时的重要部分.mach-o是一种传统的基于section和symbol的文件格式,解析器必须使用两种方法来推断`Atom`边界:
1. 第一种方法是，有些section类型有明确定义的内容，链接器可以将其解析成`Atom`(例如__cstring、__eh_frame).
2. 另一种方法是根据命名惯例（编译器遵循这个惯例），链接器在任何非本地（不是以'L'开头的）符号处将section分成`Atom`.

考虑到汇编器只写一次目标文件，而链接器则会多次读取目标文件（在开发过程中），因此优化目标文件格式，使之成为链接器可以有效地读取/解析的文件格式是有意义的.
注意到在darwin linker中，输入对象文件的格式与输出的可执行格式无关。也就是说，我们可以有一个更友好通用的文件格式，链接器可以用它作为输入来生成mach-o、ELF或PE可执行文件.

比如在目前iOS组件二进制化编译加速的基础上, 我们可以将二进制库转化成ld更好解析的文本表示或二进制文件格式.在链接的时候直接读取该文件从而提升链接速度.官方也在Future Directions中提供了一种YAML格式的例子, 有兴趣的可以学习下.

#### 使用zld
zld是一个基于ld优化的版本, 主要通过以下几种方式:
1. 目标文件和库名缓存;
2. 使用Swiss Tables替代STL;
3. 并发操作(比如解析库、输出文件、排序等)
4. 字符串散列的优化（缓存散列，使用更好的散列函数等）

#### 其他
相对来说上面两种方案等替换成本相对比较大, 这里还有一些低成本的可以选择
- 合并静态库
- 优化编译参数 
  1. `-Wl,-no_uuid`: 禁止创建UUID;
  2. 关闭`DEAD_CODE_STRIPPING`;
  3. 对于可执行文件和xctest包使用`-Wl,-exported_symbols_list,/dev/null`,禁用DYLD导出TRIE;
  4. `-Wl,-no_deduplicate`: 禁用去重(DEBUG默认开启);
  5. `-Wl,-no_compact_unwind`: 关闭compact unwind info的创建.(注意:对于Objective-C和C++的函数如果链接时没有创建compact unwind info, 当遇到一个异常unwinds时会crash.而Swift函数不受影响, 所以对于pure Swift的项目可以使用;
  6. 使用`-Wl,-force_load`;
  7. 用动态库替代静态库;
  
### 参考
- Inside the Linker
- zld


![公众号](https://mmbiz.qpic.cn/sz_mmbiz_png/eB0h4dLLiaktdfN6hbNkBlHNicfh9JIDzhklEdfYcbOpKUVYicckYkPN3yU6vQe8yUZj5crLB8aVPuRGR2oc4rn1Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)