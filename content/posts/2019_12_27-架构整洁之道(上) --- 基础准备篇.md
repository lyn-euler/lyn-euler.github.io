---
title: "架构整洁之道 --- 基础准备篇"
date: "2019-12-27"
---
<!--> 人生不是什么冒险, 而是一股莫之能驭的洪流-->

架构一词相信很多技术开发的同学在工作中经常接触到, 甚至于不少同学在求职简历中介绍自己工作的内容有不少也写着譬如`架构改进`相关的术语. 但对于架构的工作理论知识却知之甚少, 更多的还停留在“构造文件夹”的层面. 在阅读本文之前我们不妨来尝试回答一下问题.
- 什么是你理解的架构, 架构的价值在哪里.
- 你简历中的架构改进, 主要做了哪些工作.
- 你知道哪些架构模式, 有哪些架构设计中的原则, 你在做架构设计的时候是如何进行的.
- 分层架构里你通过什么去界定每一层.

这个系列将通过介绍架构相关的知识, 来尝试性给这些问题提供回答的方向.
- [基础准备篇](#)
- [架构模式篇]()

下面是准备篇的内容
![目录-w400](/15772357560520/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84.png)


## 什么是软件架构
**架构（architecture）**一词大概是源于建筑学，也常指建筑物在其尺度上是如何依靠内部的支撑物相互结合而稳固构造的方式。
**软件架构（software architecture）**是一系列相关的抽象模式，用于指导大型软件系统各个方面的设计. 而广义的理解这里的抽象模式不仅仅只是技术的选型, 框架的输出. 它应该是贯穿在整个问题解决方案的方方面面, 包括对技术的组织, 业务的组织, 资源(包括人员)的组织. 本文下面所有的"架构"一词不做特殊说明都是指软件架构中对系统或工程的组织.

## 软件架构的价值和目标
既然要聊是软件架构的价值, 那首先我们要了解软件系统的价值所在. 软件(Software)的价值有两方面:**行为价值**(表现)和**架构价值**(结构). 这也是对 `software` 这个词的拆解:
- 行为价值 
`ware`表示商品, 也就是软件所表现出的商品属性. 也就是软件的表现, 包括需求的实现, 以及可用性保障(性能、功能可用性等).
- 架构价值 
`soft` 表示软件的结构可扩展易修改属性. 可以从两方面理解
  1. 当利益相关者想要改一个需求，所需的软件变更必须简单方便;
  2. 变更实施的难度应该和变更的范畴（scope）成等比，而与变更的具体形状（shape）无关.

在我看来这两个价值关系就像“鹅与金蛋”的关系: 行为价值代表着‘产量’, 决定了利益相关者的实际收益; 架构价值代表‘产能’, 它为行为价值提供支撑, 提升软件系统的服务能力和生产效率. 在实际生产中关键是找准两者的平衡点, 平衡点是对投入产出比的考量、对现有资源的妥协, 而这本身也是架构工作的一部分.
至于架构的目标就是为了实现架构的价值, 通俗的讲就是用更少的资源构建软件系统实现需求(它应该贯穿于软件系统的开发、部署、运行、维护等整个生命周期).而一般情况下, 我们为软件构建中层结构的主要目标
- 使软件可容忍被改动
- 使软件更容易理解
- 构建可在多个软件系统中复用的组件

一个软件架构的优劣, 可以用它满足用户需求所需要的成本来衡量. 如果在系统的整个生命周期内一直维持低成本, 那么这个系统设计就是优良的. 那么我们应该如何设计一个优良的架构呢?

## 好的架构从代码开始
任何软件架构的实现都依赖于具体的代码, 所以要想构建好的软件系统, 应该从整洁的代码开始. 
毕竟建筑设计的再好, 如果使用的砖头质量不好, 架构能起到的作用也是微乎其微的. 同时如何组织这些砖头也很大程度上决定了建筑的整体质量. 在软件编程领域`编程范式`和`SOLID 设计原则`给了很好的理论指导和实践基础. 

### 编程范式
**编程范式 (paradigm)** 指的是程序的编写模式. 
其实所谓架构就是限制，限制源码放在哪里、限制依赖、限制通信的方式，但这些限制比较上层。编程范式是最基础的限制，它限制我们的控制流和数据流：
- `结构化编程`对程序控制权的直接转移进行了限制和规范;
- `面向对象编程`对程序控制权的间接转移进行了限制和规范;
- `函数式编程`对程序中的赋值进行了限制和规范;

### SOLID设计原则
SOLID原则的主要作用就是告诉我们如何将数据和函数组织成为类(这里的类区别于面向对象编程中的类, 它代表了一种数据和函数的分组),以及如何建这些累链接起来成为程序.
- **单一职责原则(SRP)** 
  任何一个软件模块都应该只对某一类行为负责. 该设计是基于康威定律(Conway's Law)的一个推论 --- 一个软件系统的最佳结构高度依赖于开发这个系统的组织内部结构.
  
- **开闭原则(OCP)**
  设计良好的计算机软件应该易于扩展, 同时抗拒修改.

- **里氏替换原则(LSP)**
  如果想用可替换的组件来构建软件系统, 那么这些组件必须遵循同一个约定, 以便让这些组件可以相互替换.
  
- **接口隔离原则(ISP)**
  该设计原则主要告诫软件设计师应该在设计中避免不必要的依赖.
  
- **依赖反转原则(DIP)**
  该设计原则指出高层策略性的代码不应该依赖底层实现细节, 相反实现底层细节的代码应该依赖高层策略性代码.


### 组件构建原则
当然, 正如一块好砖也会盖歪楼一样, 采用良好的中层组件并不能保障系统的整体运作良好. 所以有必要再针对组件的设计原则进一步的讨论. 如果说SOLID原则是指导我们如何将砖砌成墙和房间, 那么组件构建原则就是指导我们如何将这些房间组合成房子.

#### 组件聚合
那么哪些类应该被合成一个组件? 这是一个非常重要的设计决策 应该遵循优秀的软件工程经验, 下面介绍三个与构建组件相关的基本原则:
- **复用/发布等同原则(REP)**
  软件复用的最小力度应等同于其发布的最小粒度.
  
- **共同闭包原则(CCP)**
  我们应该将哪些会同时修改, 并且为相同目的而修改的类放到一个组件中, 而将不同时修改或不会为了相同目的而修改的类放到不同组件中.

- **共同复用原则(CRP)**
  不要强迫一个组件的用户依赖他们不需要的东西.
  
仔细的读者大概已经意识到这三个原则之前是存在竞争的关系. `REP` 和 `CCP` 原则是粘合性原则, 而 `CRP` 原则是排除性原则. 架构的工作就要在这三个原则中进行取舍, 优秀的架构师应该在这三角区域中定位一个最适合当前研发团队的位置, 同时根据时间和实际情况不停调整. 组件的构成安排应该随着项目重心的不同, 以及研发性和复用性的不同而不断演化.
![2509688-6782d4674ddb5416](/15772357560520/2509688-6782d4674ddb5416.png)


#### 组件耦合
按上面的原则类被合成一个个组件, 那么组件间的关系又该如何处理. 
- **无依赖环原则**
  组件依赖关系图中不应该出现环. 
  针对`每周构建`中通过频繁的构建影响高效率开发, 延长构建时间间隔影响项目质量, 增大风险的情景, 通过独立组件发布可以消除影响, 但必须保障组件间没有依赖环. 可以通过**依赖反转原则`DIP`**和**创建共同依赖的新组件**的方式来解决.
  
- **稳定依赖原则(SDP)**
  依赖关系必须要指向更稳定的方向.
  这里组件的稳定性指的是它的变更成本，和它变更的频繁度没有直接的关联(变更的频繁程度与需求的稳定性更加相关). 那么, 如何衡量一个组件的稳定性呢? 其中一种方法是计算所有入和出的依赖关系.
  1. `入向依赖(Fan-in)`这个指标指带了组件内部类的数量.
  2. `出向依赖(Fan-out)`指代组件内部类依赖于组件外部类的数量.
  3. `不稳定性(I)` I=Fon-out/(Fan-in + Fon-out).
如果发现违反稳定依赖原则的地方，解决的办法也是通过 `DIP` 来反转依赖

- **稳定抽象原则(SAP)**
  一个组件的抽象化程度应该与其稳定性保持一致.
  为了防止业务决策和架构设计经常变更, 我们需要把代表系统高阶决策的组件放到稳定组件中. 然而如果我们这么做, 那么用于秒杀那些策略的源代码就难以修改. 为了防止高阶策略难以修改，根据开闭原则`OCP`通常我们应该抽象出稳定的接口、抽象类为单独的组件，让具体实现的组件依赖于接口组件，这样它的稳定性就不会影响它的扩展性.
 衡量抽象化程度: `A=Na/Nc` (其中 *Nc* 代表组件中类的数量, *Na* 代表组件中抽象类和接口的数量)
 将不稳定性（I）作为横轴，抽象程度（A）作为纵轴，那么最稳定、只包含抽象类和接口的组件应该位于左上角（0，1），最不稳定、只包含具体实现类，没有任何接口的组件应该位于右下角（1，0），他们连线就是主序列线，位于线上的组件，他们的稳定性和抽象程度相匹配，是设计良好的组件。位于（0，0）周围区域的组件，它们是非常稳定（注意这里的稳定指的是变更成本）并且非常具体的组件，因为他们的抽象程度低，决定了他们经常改动的命运，但是又有许多其他组件依赖他们，改起来非常痛苦，所以这个区域叫做痛苦区。右上角区域的组件，没有其他组件依赖他们，他们自身的抽象程度又很高，很有可能是陈年的老代码，所以这个区域叫做无用区。
![2509688-ba960017b35b8e22](/15772357560520/2509688-ba960017b35b8e22.png)
另外，可以用点距离主序列线的距离 Z 来表示组件是否遵循稳定抽象原则，Z 越大表示组件越违背稳定依赖原则。

## 参考
[The Clean Code Blog](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)

